{
    "updatedAt": "2026-02-25T23:10:59.085Z",
    "createdAt": "2026-02-21T20:19:31.453Z",
    "id": "G97hHxiJWwXG0ejD",
    "name": "Doppler Blog Image Search",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
        {
            "parameters": {
                "httpMethod": "POST",
                "path": "find-image",
                "responseMode": "responseNode",
                "options": {}
            },
            "id": "webhook-trigger",
            "name": "Webhook (Find Image)",
            "type": "n8n-nodes-base.webhook",
            "typeVersion": 2,
            "position": [
                0,
                0
            ],
            "webhookId": "find-image"
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(120000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst input = $input.first().json.body || $input.first().json;\nconst title = input.title || '';\nconst content = (input.content || '').slice(0, 1500);\nconst slug = input.slug || '';\nconst tags = input.tags || [];\n\n// 6 distinct visual style templates for variety\nconst styleTemplates = [\n  {\n    name: 'editorial-photo',\n    template: 'Photorealistic editorial photography, captured with a [CAMERA] [LENS]. [SCENE]. [LIGHTING]. The color palette is slightly desaturated, reminiscent of [FILM] film stock. Shallow depth of field, with soft bokeh in the background. Eye-level shot, composed using the rule of thirds. Cinematic, raw style.',\n    instruction: 'Create a photorealistic editorial scene.'\n  },\n  {\n    name: 'flat-illustration',\n    template: 'Modern flat vector illustration in a clean tech-startup style. [SCENE]. Bold geometric shapes, smooth gradients transitioning from deep navy (#1a1a2e) to vibrant teal (#00d4aa) \u2014 the Doppler VPN brand palette. Minimal negative space, no text, no UI. Abstract tech patterns with flowing curved lines suggesting data flow and security. Subtle dot grid overlay. 16:9 aspect ratio.',\n    instruction: 'Create a modern flat illustration \u2014 NO photorealism.'\n  },\n  {\n    name: 'isometric-3d',\n    template: 'Clean isometric 3D illustration with soft ambient occlusion shadows. [SCENE]. Rendered in a low-poly style with smooth surfaces and rounded edges. Color scheme: deep navy background (#0f0f23) with glowing teal (#00d4aa) and electric blue (#3b82f6) accents. Soft volumetric lighting from upper-left. No text, no logos. Minimal, professional, tech aesthetic.',\n    instruction: 'Create an isometric 3D scene \u2014 think tech infographics style.'\n  },\n  {\n    name: 'cinematic-wide',\n    template: 'Ultra-wide cinematic landscape photograph, 2.39:1 aspect ratio feel. [SCENE]. Captured with an Arri Alexa using anamorphic lenses \u2014 visible lens flare, horizontal streak highlights. Teal and orange color grading. Deep shadows, rich highlights. Volumetric haze or fog adding depth layers. Epic scale, small human silhouette for perspective. No text.',\n    instruction: 'Create an ultra-wide cinematic landscape with dramatic scale.'\n  },\n  {\n    name: 'abstract-data',\n    template: 'Abstract data visualization artwork. [SCENE]. Flowing particle streams, interconnected nodes with glowing edges, digital mesh surfaces. Color palette: dark background with luminous teal (#00d4aa), purple (#7c3aed), and blue (#3b82f6) light trails. Long exposure feel \u2014 light painting with digital elements. Mathematical precision meets organic flow. No text, no UI mockups.',\n    instruction: 'Create abstract data/network visualization art \u2014 think generative art.'\n  },\n  {\n    name: 'macro-detail',\n    template: 'Extreme macro photography with focus stacking. [SCENE]. Captured with a Hasselblad X2D, 120mm macro lens. Razor-sharp focal plane with creamy bokeh dissolving into abstract color. Dramatic side lighting revealing surface texture and detail. Rich, saturated colors with deep blacks. Studio-quality, museum-worthy print resolution. No text.',\n    instruction: 'Create an extreme macro photograph that reveals hidden detail and texture.'\n  }\n];\n\n// Pick a style based on slug hash for consistency (same slug = same style)\nconst hash = slug.split('').reduce((a, c) => ((a << 5) - a + c.charCodeAt(0)) | 0, 0);\nconst styleIndex = Math.abs(hash) % styleTemplates.length;\nconst style = styleTemplates[styleIndex];\n\nconst systemPrompt = `You are a creative director for Doppler VPN's blog. Given a blog post title and excerpt, write an image generation prompt.\n\nYour chosen visual style for this piece: \"${style.name}\"\n${style.instruction}\n\nGuidelines:\n1. Analyze the article's theme and emotional tone\n2. Write a vivid, specific scene description (2-3 sentences) that captures the article's essence\n3. The scene should feel unique and specific \u2014 avoid generic \"person at computer\" or \"lock icon\" clich\u00e9s\n4. Incorporate subtle privacy/security visual metaphors when relevant (shields, tunnels, encrypted streams, secure pathways)\n5. NEVER include readable text, logos, UI elements, or screenshots in the scene\n\nUse this template:\n${style.template}\n\nReplace [SCENE] with your scene description. Replace other [BRACKETS] with appropriate values.\nFor photography styles, choose camera/lens that fits the mood.\nFor illustration styles, describe the visual elements and composition.\n\nBrand color reference (use where appropriate):\n- Primary teal: #00d4aa\n- Deep navy: #0f0f23 / #1a1a2e\n- Accent blue: #3b82f6\n- Accent purple: #7c3aed\n\nRespond with ONLY the complete image prompt, nothing else.`;\n\nconst userPrompt = `Blog title: ${title}\\n\\nBlog excerpt:\\n${content.slice(0, 800)}\\n\\nTags: ${tags.join(', ')}`;\n\nconst openaiRes = await httpsPost('api.openai.com', '/v1/chat/completions', {\n  'Authorization': 'Bearer ' + $env.OPENAI_API_KEY\n}, {\n  model: 'gpt-5-mini',\n  messages: [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: userPrompt }\n  ],\n  max_completion_tokens: 4000\n});\n\nif (openaiRes.status !== 200) {\n  throw new Error('OpenAI failed (' + openaiRes.status + '): ' + openaiRes.body.slice(0, 300));\n}\n\nconst openaiData = JSON.parse(openaiRes.body);\nconst imagePrompt = openaiData.choices?.[0]?.message?.content?.trim();\n\nif (!imagePrompt) {\n  throw new Error('OpenAI returned empty prompt: ' + JSON.stringify(openaiData).slice(0, 500));\n}\n\nreturn [{ json: { slug, imagePrompt, style: style.name } }];"
            },
            "id": "generate-prompt",
            "name": "Generate Image Prompt",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                250,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsRequest(method, hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const isBuffer = Buffer.isBuffer(body);\n    const data = isBuffer ? body : (body ? JSON.stringify(body) : '');\n    const hdrs = { ...headers };\n    if (!isBuffer && body) hdrs['Content-Type'] = 'application/json';\n    hdrs['Content-Length'] = Buffer.byteLength(data);\n    const opts = { hostname, path, method, headers: hdrs };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(120000, () => { req.destroy(new Error('timeout')); });\n    if (data) req.write(data);\n    req.end();\n  });\n}\n\nconst slug = $json.slug;\nconst imagePrompt = $json.imagePrompt;\nconst geminiKey = $env.GEMINI_API_KEY;\n\n// Add subtle Doppler VPN branding instruction to the prompt\nconst brandedPrompt = imagePrompt + '\\n\\nIMPORTANT BRANDING: In the bottom-right corner, include a small, elegant, semi-transparent watermark that says \"Doppler VPN\" in a clean sans-serif font (like Inter or Helvetica). The watermark should be subtle \u2014 about 15% opacity white text, small size, professional placement. It should not distract from the main image.';\n\n// Call Gemini to generate the image\nconst geminiRes = await httpsRequest('POST',\n  'generativelanguage.googleapis.com',\n  '/v1beta/models/gemini-2.5-flash-image:generateContent?key=' + geminiKey,\n  {},\n  {\n    contents: [{ parts: [{ text: brandedPrompt }] }],\n    generationConfig: {\n      responseModalities: ['IMAGE'],\n      imageConfig: { aspectRatio: '16:9' }\n    }\n  }\n);\n\nif (geminiRes.status !== 200) {\n  throw new Error('Gemini failed (' + geminiRes.status + '): ' + geminiRes.body.slice(0, 500));\n}\n\nconst geminiData = JSON.parse(geminiRes.body);\nconst parts = geminiData.candidates?.[0]?.content?.parts || [];\nconst imagePart = parts.find(p => p.inlineData);\n\nif (!imagePart) {\n  throw new Error('Gemini did not return an image: ' + JSON.stringify(geminiData).slice(0, 500));\n}\n\nconst base64Data = imagePart.inlineData.data;\nconst mimeType = imagePart.inlineData.mimeType || 'image/png';\nconst ext = mimeType === 'image/jpeg' ? 'jpg' : 'png';\nconst filename = slug + '.' + ext;\nconst imageBuffer = Buffer.from(base64Data, 'base64');\n\n// Upload to Supabase Storage\nconst supabaseUrl = $env.SUPABASE_URL;\nconst serviceKey = $env.SUPABASE_SERVICE_KEY;\nconst supabaseHost = supabaseUrl.replace('https://', '');\n\nconst uploadRes = await httpsRequest('POST',\n  supabaseHost,\n  '/storage/v1/object/blog-images/' + encodeURIComponent(filename),\n  {\n    'Authorization': 'Bearer ' + serviceKey,\n    'apikey': serviceKey,\n    'Content-Type': mimeType,\n    'x-upsert': 'true'\n  },\n  imageBuffer\n);\n\nif (uploadRes.status !== 200) {\n  throw new Error('Storage upload failed (' + uploadRes.status + '): ' + uploadRes.body.slice(0, 300));\n}\n\nconst publicUrl = supabaseUrl + '/storage/v1/object/public/blog-images/' + filename;\n\n// Update blog_posts.image_url\nconst patchRes = await httpsRequest('PATCH',\n  supabaseHost,\n  '/rest/v1/blog_posts?slug=eq.' + encodeURIComponent(slug),\n  {\n    'Authorization': 'Bearer ' + serviceKey,\n    'apikey': serviceKey,\n    'Content-Type': 'application/json',\n    'Prefer': 'return=minimal'\n  },\n  { image_url: publicUrl }\n);\n\nif (patchRes.status !== 204 && patchRes.status !== 200) {\n  throw new Error('DB update failed (' + patchRes.status + '): ' + patchRes.body.slice(0, 300));\n}\n\nreturn [{ json: { slug, success: true, image_url: publicUrl } }];"
            },
            "id": "generate-upload",
            "name": "Generate & Upload Image",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                500,
                0
            ],
            "continueOnFail": true
        },
        {
            "parameters": {
                "conditions": {
                    "options": {
                        "caseSensitive": true,
                        "leftValue": "",
                        "typeValidation": "strict"
                    },
                    "conditions": [
                        {
                            "leftValue": "={{ $json.success }}",
                            "rightValue": true,
                            "operator": {
                                "type": "boolean",
                                "operation": "true"
                            }
                        }
                    ],
                    "combinator": "and"
                }
            },
            "id": "if-success",
            "name": "If Success",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                750,
                0
            ]
        },
        {
            "parameters": {
                "respondWith": "json",
                "responseBody": "={{ JSON.stringify({ success: true, slug: $json.slug, image_url: $json.image_url }) }}"
            },
            "id": "respond-success",
            "name": "Respond Success",
            "type": "n8n-nodes-base.respondToWebhook",
            "typeVersion": 1.1,
            "position": [
                1000,
                -100
            ]
        },
        {
            "parameters": {
                "respondWith": "json",
                "responseBody": "={{ JSON.stringify({ success: false, slug: $('Generate Image Prompt').first().json.slug || 'unknown', error: $json.error?.message || 'Image generation failed' }) }}"
            },
            "id": "respond-error",
            "name": "Respond Error",
            "type": "n8n-nodes-base.respondToWebhook",
            "typeVersion": 1.1,
            "position": [
                1000,
                100
            ]
        }
    ],
    "connections": {
        "Webhook (Find Image)": {
            "main": [
                [
                    {
                        "node": "Generate Image Prompt",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Generate Image Prompt": {
            "main": [
                [
                    {
                        "node": "Generate & Upload Image",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Generate & Upload Image": {
            "main": [
                [
                    {
                        "node": "If Success",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "If Success": {
            "main": [
                [
                    {
                        "node": "Respond Success",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Respond Error",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1",
        "callerPolicy": "workflowsFromSameOwner",
        "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "e48662d7-0ae1-40ef-864a-64f8bbc40dfe",
    "activeVersionId": "e48662d7-0ae1-40ef-864a-64f8bbc40dfe",
    "versionCounter": 77,
    "triggerCount": 1,
    "shared": [
        {
            "updatedAt": "2026-02-21T20:19:31.457Z",
            "createdAt": "2026-02-21T20:19:31.457Z",
            "role": "workflow:owner",
            "workflowId": "G97hHxiJWwXG0ejD",
            "projectId": "EONlUm0d92HHHVBN",
            "project": {
                "updatedAt": "2026-02-25T02:05:40.807Z",
                "createdAt": "2026-02-15T17:41:33.246Z",
                "id": "EONlUm0d92HHHVBN",
                "name": "Roman Pochtman <pochtmanrca@gmail.com>",
                "type": "personal",
                "icon": null,
                "description": null,
                "creatorId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                "projectRelations": [
                    {
                        "updatedAt": "2026-02-15T17:41:33.246Z",
                        "createdAt": "2026-02-15T17:41:33.246Z",
                        "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                        "projectId": "EONlUm0d92HHHVBN",
                        "user": {
                            "updatedAt": "2026-02-26T00:55:17.000Z",
                            "createdAt": "2026-02-25T01:40:25.011Z",
                            "id": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                            "email": "pochtmanrca@gmail.com",
                            "firstName": "Roman",
                            "lastName": "Pochtman",
                            "personalizationAnswers": null,
                            "settings": {
                                "firstSuccessfulWorkflowId": "CoWsngJ0UMOjyzFL",
                                "userActivated": true,
                                "userActivatedAt": 1772064788001
                            },
                            "disabled": false,
                            "mfaEnabled": false,
                            "lastActiveAt": "2026-02-25",
                            "isPending": false
                        }
                    }
                ]
            }
        }
    ],
    "tags": [],
    "activeVersion": {
        "updatedAt": "2026-02-25T23:10:59.086Z",
        "createdAt": "2026-02-25T23:10:59.086Z",
        "versionId": "e48662d7-0ae1-40ef-864a-64f8bbc40dfe",
        "workflowId": "G97hHxiJWwXG0ejD",
        "nodes": [
            {
                "parameters": {
                    "httpMethod": "POST",
                    "path": "find-image",
                    "responseMode": "responseNode",
                    "options": {}
                },
                "id": "webhook-trigger",
                "name": "Webhook (Find Image)",
                "type": "n8n-nodes-base.webhook",
                "typeVersion": 2,
                "position": [
                    0,
                    0
                ],
                "webhookId": "find-image"
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(120000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst input = $input.first().json.body || $input.first().json;\nconst title = input.title || '';\nconst content = (input.content || '').slice(0, 1500);\nconst slug = input.slug || '';\nconst tags = input.tags || [];\n\n// 6 distinct visual style templates for variety\nconst styleTemplates = [\n  {\n    name: 'editorial-photo',\n    template: 'Photorealistic editorial photography, captured with a [CAMERA] [LENS]. [SCENE]. [LIGHTING]. The color palette is slightly desaturated, reminiscent of [FILM] film stock. Shallow depth of field, with soft bokeh in the background. Eye-level shot, composed using the rule of thirds. Cinematic, raw style.',\n    instruction: 'Create a photorealistic editorial scene.'\n  },\n  {\n    name: 'flat-illustration',\n    template: 'Modern flat vector illustration in a clean tech-startup style. [SCENE]. Bold geometric shapes, smooth gradients transitioning from deep navy (#1a1a2e) to vibrant teal (#00d4aa) \u2014 the Doppler VPN brand palette. Minimal negative space, no text, no UI. Abstract tech patterns with flowing curved lines suggesting data flow and security. Subtle dot grid overlay. 16:9 aspect ratio.',\n    instruction: 'Create a modern flat illustration \u2014 NO photorealism.'\n  },\n  {\n    name: 'isometric-3d',\n    template: 'Clean isometric 3D illustration with soft ambient occlusion shadows. [SCENE]. Rendered in a low-poly style with smooth surfaces and rounded edges. Color scheme: deep navy background (#0f0f23) with glowing teal (#00d4aa) and electric blue (#3b82f6) accents. Soft volumetric lighting from upper-left. No text, no logos. Minimal, professional, tech aesthetic.',\n    instruction: 'Create an isometric 3D scene \u2014 think tech infographics style.'\n  },\n  {\n    name: 'cinematic-wide',\n    template: 'Ultra-wide cinematic landscape photograph, 2.39:1 aspect ratio feel. [SCENE]. Captured with an Arri Alexa using anamorphic lenses \u2014 visible lens flare, horizontal streak highlights. Teal and orange color grading. Deep shadows, rich highlights. Volumetric haze or fog adding depth layers. Epic scale, small human silhouette for perspective. No text.',\n    instruction: 'Create an ultra-wide cinematic landscape with dramatic scale.'\n  },\n  {\n    name: 'abstract-data',\n    template: 'Abstract data visualization artwork. [SCENE]. Flowing particle streams, interconnected nodes with glowing edges, digital mesh surfaces. Color palette: dark background with luminous teal (#00d4aa), purple (#7c3aed), and blue (#3b82f6) light trails. Long exposure feel \u2014 light painting with digital elements. Mathematical precision meets organic flow. No text, no UI mockups.',\n    instruction: 'Create abstract data/network visualization art \u2014 think generative art.'\n  },\n  {\n    name: 'macro-detail',\n    template: 'Extreme macro photography with focus stacking. [SCENE]. Captured with a Hasselblad X2D, 120mm macro lens. Razor-sharp focal plane with creamy bokeh dissolving into abstract color. Dramatic side lighting revealing surface texture and detail. Rich, saturated colors with deep blacks. Studio-quality, museum-worthy print resolution. No text.',\n    instruction: 'Create an extreme macro photograph that reveals hidden detail and texture.'\n  }\n];\n\n// Pick a style based on slug hash for consistency (same slug = same style)\nconst hash = slug.split('').reduce((a, c) => ((a << 5) - a + c.charCodeAt(0)) | 0, 0);\nconst styleIndex = Math.abs(hash) % styleTemplates.length;\nconst style = styleTemplates[styleIndex];\n\nconst systemPrompt = `You are a creative director for Doppler VPN's blog. Given a blog post title and excerpt, write an image generation prompt.\n\nYour chosen visual style for this piece: \"${style.name}\"\n${style.instruction}\n\nGuidelines:\n1. Analyze the article's theme and emotional tone\n2. Write a vivid, specific scene description (2-3 sentences) that captures the article's essence\n3. The scene should feel unique and specific \u2014 avoid generic \"person at computer\" or \"lock icon\" clich\u00e9s\n4. Incorporate subtle privacy/security visual metaphors when relevant (shields, tunnels, encrypted streams, secure pathways)\n5. NEVER include readable text, logos, UI elements, or screenshots in the scene\n\nUse this template:\n${style.template}\n\nReplace [SCENE] with your scene description. Replace other [BRACKETS] with appropriate values.\nFor photography styles, choose camera/lens that fits the mood.\nFor illustration styles, describe the visual elements and composition.\n\nBrand color reference (use where appropriate):\n- Primary teal: #00d4aa\n- Deep navy: #0f0f23 / #1a1a2e\n- Accent blue: #3b82f6\n- Accent purple: #7c3aed\n\nRespond with ONLY the complete image prompt, nothing else.`;\n\nconst userPrompt = `Blog title: ${title}\\n\\nBlog excerpt:\\n${content.slice(0, 800)}\\n\\nTags: ${tags.join(', ')}`;\n\nconst openaiRes = await httpsPost('api.openai.com', '/v1/chat/completions', {\n  'Authorization': 'Bearer ' + $env.OPENAI_API_KEY\n}, {\n  model: 'gpt-5-mini',\n  messages: [\n    { role: 'system', content: systemPrompt },\n    { role: 'user', content: userPrompt }\n  ],\n  max_completion_tokens: 4000\n});\n\nif (openaiRes.status !== 200) {\n  throw new Error('OpenAI failed (' + openaiRes.status + '): ' + openaiRes.body.slice(0, 300));\n}\n\nconst openaiData = JSON.parse(openaiRes.body);\nconst imagePrompt = openaiData.choices?.[0]?.message?.content?.trim();\n\nif (!imagePrompt) {\n  throw new Error('OpenAI returned empty prompt: ' + JSON.stringify(openaiData).slice(0, 500));\n}\n\nreturn [{ json: { slug, imagePrompt, style: style.name } }];"
                },
                "id": "generate-prompt",
                "name": "Generate Image Prompt",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    250,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsRequest(method, hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const isBuffer = Buffer.isBuffer(body);\n    const data = isBuffer ? body : (body ? JSON.stringify(body) : '');\n    const hdrs = { ...headers };\n    if (!isBuffer && body) hdrs['Content-Type'] = 'application/json';\n    hdrs['Content-Length'] = Buffer.byteLength(data);\n    const opts = { hostname, path, method, headers: hdrs };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(120000, () => { req.destroy(new Error('timeout')); });\n    if (data) req.write(data);\n    req.end();\n  });\n}\n\nconst slug = $json.slug;\nconst imagePrompt = $json.imagePrompt;\nconst geminiKey = $env.GEMINI_API_KEY;\n\n// Add subtle Doppler VPN branding instruction to the prompt\nconst brandedPrompt = imagePrompt + '\\n\\nIMPORTANT BRANDING: In the bottom-right corner, include a small, elegant, semi-transparent watermark that says \"Doppler VPN\" in a clean sans-serif font (like Inter or Helvetica). The watermark should be subtle \u2014 about 15% opacity white text, small size, professional placement. It should not distract from the main image.';\n\n// Call Gemini to generate the image\nconst geminiRes = await httpsRequest('POST',\n  'generativelanguage.googleapis.com',\n  '/v1beta/models/gemini-2.5-flash-image:generateContent?key=' + geminiKey,\n  {},\n  {\n    contents: [{ parts: [{ text: brandedPrompt }] }],\n    generationConfig: {\n      responseModalities: ['IMAGE'],\n      imageConfig: { aspectRatio: '16:9' }\n    }\n  }\n);\n\nif (geminiRes.status !== 200) {\n  throw new Error('Gemini failed (' + geminiRes.status + '): ' + geminiRes.body.slice(0, 500));\n}\n\nconst geminiData = JSON.parse(geminiRes.body);\nconst parts = geminiData.candidates?.[0]?.content?.parts || [];\nconst imagePart = parts.find(p => p.inlineData);\n\nif (!imagePart) {\n  throw new Error('Gemini did not return an image: ' + JSON.stringify(geminiData).slice(0, 500));\n}\n\nconst base64Data = imagePart.inlineData.data;\nconst mimeType = imagePart.inlineData.mimeType || 'image/png';\nconst ext = mimeType === 'image/jpeg' ? 'jpg' : 'png';\nconst filename = slug + '.' + ext;\nconst imageBuffer = Buffer.from(base64Data, 'base64');\n\n// Upload to Supabase Storage\nconst supabaseUrl = $env.SUPABASE_URL;\nconst serviceKey = $env.SUPABASE_SERVICE_KEY;\nconst supabaseHost = supabaseUrl.replace('https://', '');\n\nconst uploadRes = await httpsRequest('POST',\n  supabaseHost,\n  '/storage/v1/object/blog-images/' + encodeURIComponent(filename),\n  {\n    'Authorization': 'Bearer ' + serviceKey,\n    'apikey': serviceKey,\n    'Content-Type': mimeType,\n    'x-upsert': 'true'\n  },\n  imageBuffer\n);\n\nif (uploadRes.status !== 200) {\n  throw new Error('Storage upload failed (' + uploadRes.status + '): ' + uploadRes.body.slice(0, 300));\n}\n\nconst publicUrl = supabaseUrl + '/storage/v1/object/public/blog-images/' + filename;\n\n// Update blog_posts.image_url\nconst patchRes = await httpsRequest('PATCH',\n  supabaseHost,\n  '/rest/v1/blog_posts?slug=eq.' + encodeURIComponent(slug),\n  {\n    'Authorization': 'Bearer ' + serviceKey,\n    'apikey': serviceKey,\n    'Content-Type': 'application/json',\n    'Prefer': 'return=minimal'\n  },\n  { image_url: publicUrl }\n);\n\nif (patchRes.status !== 204 && patchRes.status !== 200) {\n  throw new Error('DB update failed (' + patchRes.status + '): ' + patchRes.body.slice(0, 300));\n}\n\nreturn [{ json: { slug, success: true, image_url: publicUrl } }];"
                },
                "id": "generate-upload",
                "name": "Generate & Upload Image",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    500,
                    0
                ],
                "continueOnFail": true
            },
            {
                "parameters": {
                    "conditions": {
                        "options": {
                            "caseSensitive": true,
                            "leftValue": "",
                            "typeValidation": "strict"
                        },
                        "conditions": [
                            {
                                "leftValue": "={{ $json.success }}",
                                "rightValue": true,
                                "operator": {
                                    "type": "boolean",
                                    "operation": "true"
                                }
                            }
                        ],
                        "combinator": "and"
                    }
                },
                "id": "if-success",
                "name": "If Success",
                "type": "n8n-nodes-base.if",
                "typeVersion": 2,
                "position": [
                    750,
                    0
                ]
            },
            {
                "parameters": {
                    "respondWith": "json",
                    "responseBody": "={{ JSON.stringify({ success: true, slug: $json.slug, image_url: $json.image_url }) }}"
                },
                "id": "respond-success",
                "name": "Respond Success",
                "type": "n8n-nodes-base.respondToWebhook",
                "typeVersion": 1.1,
                "position": [
                    1000,
                    -100
                ]
            },
            {
                "parameters": {
                    "respondWith": "json",
                    "responseBody": "={{ JSON.stringify({ success: false, slug: $('Generate Image Prompt').first().json.slug || 'unknown', error: $json.error?.message || 'Image generation failed' }) }}"
                },
                "id": "respond-error",
                "name": "Respond Error",
                "type": "n8n-nodes-base.respondToWebhook",
                "typeVersion": 1.1,
                "position": [
                    1000,
                    100
                ]
            }
        ],
        "connections": {
            "Webhook (Find Image)": {
                "main": [
                    [
                        {
                            "node": "Generate Image Prompt",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Generate Image Prompt": {
                "main": [
                    [
                        {
                            "node": "Generate & Upload Image",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Generate & Upload Image": {
                "main": [
                    [
                        {
                            "node": "If Success",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "If Success": {
                "main": [
                    [
                        {
                            "node": "Respond Success",
                            "type": "main",
                            "index": 0
                        }
                    ],
                    [
                        {
                            "node": "Respond Error",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            }
        },
        "authors": "Roman Pochtman",
        "name": null,
        "description": null,
        "autosaved": false,
        "workflowPublishHistory": [
            {
                "createdAt": "2026-02-25T23:10:59.134Z",
                "id": 91,
                "workflowId": "G97hHxiJWwXG0ejD",
                "versionId": "e48662d7-0ae1-40ef-864a-64f8bbc40dfe",
                "event": "activated",
                "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039"
            }
        ]
    }
}
