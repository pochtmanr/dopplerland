{
    "updatedAt": "2026-02-26T02:23:45.743Z",
    "createdAt": "2026-02-26T00:04:59.799Z",
    "id": "CoWsngJ0UMOjyzFL",
    "name": "Doppler Editorial \u2014 Content Generation",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
        {
            "parameters": {
                "httpMethod": "POST",
                "path": "doppler-content-gen",
                "responseMode": "responseNode",
                "options": {}
            },
            "id": "webhook-trigger",
            "name": "Webhook",
            "type": "n8n-nodes-base.webhook",
            "typeVersion": 2,
            "position": [
                0,
                300
            ],
            "webhookId": "doppler-content-gen"
        },
        {
            "parameters": {
                "rules": {
                    "values": [
                        {
                            "conditions": {
                                "options": {
                                    "caseSensitive": false,
                                    "leftValue": "",
                                    "typeValidation": "strict"
                                },
                                "conditions": [
                                    {
                                        "leftValue": "={{ $json.templateType }}",
                                        "rightValue": "quick-take",
                                        "operator": {
                                            "type": "string",
                                            "operation": "equals"
                                        }
                                    }
                                ],
                                "combinator": "and"
                            },
                            "renameOutput": true,
                            "outputLabel": "quick-take"
                        },
                        {
                            "conditions": {
                                "options": {
                                    "caseSensitive": false,
                                    "leftValue": "",
                                    "typeValidation": "strict"
                                },
                                "conditions": [
                                    {
                                        "leftValue": "={{ $json.templateType }}",
                                        "rightValue": "analysis",
                                        "operator": {
                                            "type": "string",
                                            "operation": "equals"
                                        }
                                    }
                                ],
                                "combinator": "and"
                            },
                            "renameOutput": true,
                            "outputLabel": "analysis"
                        },
                        {
                            "conditions": {
                                "options": {
                                    "caseSensitive": false,
                                    "leftValue": "",
                                    "typeValidation": "strict"
                                },
                                "conditions": [
                                    {
                                        "leftValue": "={{ $json.templateType }}",
                                        "rightValue": "meme",
                                        "operator": {
                                            "type": "string",
                                            "operation": "equals"
                                        }
                                    }
                                ],
                                "combinator": "and"
                            },
                            "renameOutput": true,
                            "outputLabel": "meme"
                        },
                        {
                            "conditions": {
                                "options": {
                                    "caseSensitive": false,
                                    "leftValue": "",
                                    "typeValidation": "strict"
                                },
                                "conditions": [
                                    {
                                        "leftValue": "={{ $json.templateType }}",
                                        "rightValue": "roundup",
                                        "operator": {
                                            "type": "string",
                                            "operation": "equals"
                                        }
                                    }
                                ],
                                "combinator": "and"
                            },
                            "renameOutput": true,
                            "outputLabel": "roundup"
                        }
                    ]
                },
                "options": {
                    "fallbackOutput": "extra"
                }
            },
            "id": "template-router",
            "name": "Template Router",
            "type": "n8n-nodes-base.switch",
            "typeVersion": 3.2,
            "position": [
                250,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    systemPrompt: \"You are a policy analyst writing for a tech blog. Write a 280-420 word news article about a REAL event that happened today.\\n\\nWRITING STYLE:\\n- Natural flowing prose \\u2014 NO rigid template sections like \\\"What happened\\\", \\\"Quotes\\\", \\\"Why it matters\\\"\\n- Use ## headers based on THE ACTUAL TOPIC (e.g., \\\"The 48-Hour Rule and Why It Matters\\\", \\\"Broader Regulatory Fallout\\\") \\u2014 NEVER generic labels\\n- Inline citations as [1], [2] within sentences naturally\\n- Bold **key terms** strategically (names, numbers, deadlines, laws)\\n- Mix short punchy sentences with longer explanatory ones\\n- Authoritative but accessible \\u2014 like a policy analyst writing for smart readers\\n- NO blockquote quotes. If quotes exist, paraphrase inline: \\\"as one analyst noted, ...\\\" or \\\"according to [Name], ...\\\"\\n- Weave in a privacy/VPN angle ONLY if genuinely relevant to the story \\u2014 never force it\\n- End with 2-3 sentences of practical implications for readers\\n\\nCRITICAL RULES:\\n- Do NOT add a \\\"Sources:\\\" section \\u2014 handled separately\\n- Do NOT mention Doppler VPN or any product\\n- Do NOT fabricate quotes, Twitter handles, or attributions\\n- Do NOT use formulaic AI patterns like \\\"In a landmark move...\\\" or \\\"This is a wake-up call...\\\"\\n- ONLY cover events that actually HAPPENED (announced, signed, launched, leaked). No predictions or forecasts.\\n\\nReturn ONLY valid JSON: {\\\"title\\\": \\\"...\\\", \\\"content\\\": \\\"markdown content\\\", \\\"excerpt\\\": \\\"max 200 chars\\\", \\\"meta_description\\\": \\\"max 160 chars\\\", \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\"]}\",\n    userPrompt: \"Write about: \" + data.topic + \"\\n\\nResearch:\\n\" + (data.summary || \"\") + \"\\n\\nAvailable quotes (paraphrase these inline, do NOT use blockquotes):\\n\" + JSON.stringify(data.key_quotes || []),\n    templateType: data.templateType || \"quick-take\",\n    topicCategory: data.topicCategory || \"\",\n    sourcesStr: data.sourcesStr || \"\",\n    sourceLinks: data.sourceLinks || [],\n  }\n}];"
            },
            "id": "quick-take-prompt",
            "name": "Quick-Take Prompt",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                550,
                100
            ]
        },
        {
            "parameters": {
                "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    systemPrompt: \"You are a policy analyst writing for a tech blog. Write a 560-840 word analysis piece about a REAL event that happened today.\\n\\nWRITING STYLE:\\n- Natural flowing prose across multiple ## sections with TOPIC-SPECIFIC headers (e.g., \\\"The Rise of AI-Assisted Abuse\\\", \\\"Expert Analysis: Compliance as Competitive Edge\\\")\\n- NEVER use generic headers like \\\"What happened\\\", \\\"Context\\\", \\\"Quotes\\\", \\\"Analysis\\\"\\n- Inline citations as [1], [2] within sentences naturally\\n- Bold **key terms** strategically (names, numbers, deadlines, laws, companies)\\n- Mix of short punchy sentences and longer explanatory ones\\n- Authoritative but accessible \\u2014 like a policy analyst explaining to smart readers\\n- NO blockquote quotes. Paraphrase: \\\"Legal experts at [Firm] predict...\\\" or \\\"as [Name] noted in a recent report...\\\"\\n- Include a comparative table if multiple regulations/companies/events are being contrasted (use markdown tables)\\n- Include a practical advice section near the end with concrete actionable steps for individuals and businesses\\n- Weave in a privacy/VPN angle ONLY if genuinely relevant \\u2014 never force it\\n\\nCRITICAL RULES:\\n- Do NOT add a \\\"Sources:\\\" section \\u2014 handled separately\\n- Do NOT mention Doppler VPN or any product\\n- Do NOT fabricate quotes, Twitter handles, or attributions\\n- Do NOT use formulaic AI patterns like \\\"In a landmark move...\\\" or \\\"This is a wake-up call...\\\"\\n- ONLY cover events that actually HAPPENED. No predictions or \\\"poised to\\\" language.\\n\\nReturn ONLY valid JSON: {\\\"title\\\": \\\"...\\\", \\\"content\\\": \\\"markdown content\\\", \\\"excerpt\\\": \\\"max 200 chars\\\", \\\"meta_description\\\": \\\"max 160 chars\\\", \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\"]}\",\n    userPrompt: \"Write about: \" + data.topic + \"\\n\\nResearch:\\n\" + (data.summary || \"\") + \"\\n\\nAvailable quotes (paraphrase these inline, do NOT use blockquotes):\\n\" + JSON.stringify(data.key_quotes || []),\n    templateType: data.templateType || \"analysis\",\n    topicCategory: data.topicCategory || \"\",\n    sourcesStr: data.sourcesStr || \"\",\n    sourceLinks: data.sourceLinks || [],\n  }\n}];"
            },
            "id": "analysis-prompt",
            "name": "Analysis Prompt",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                550,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    systemPrompt: \"You are a casual tech writer covering a viral moment. Write a 210-280 word post about something that blew up online today.\\n\\nWRITING STYLE:\\n- Casual, conversational tone \\u2014 like explaining drama to a friend\\n- One fun ## header or none at all \\u2014 this is a short post\\n- Keep it tight: what happened, why people care, the best reactions\\n- NO blockquote quotes. Paraphrase reactions inline: \\\"one dev quipped that...\\\" or \\\"the internet collectively lost it when...\\\"\\n- Internet humor welcome but don't try too hard\\n- Bold the **key moment** or **spicy detail**\\n- End with a witty one-liner or quick take\\n\\nCRITICAL RULES:\\n- Do NOT add a \\\"Sources:\\\" section \\u2014 handled separately\\n- Do NOT mention Doppler VPN or any product\\n- Do NOT fabricate quotes or Twitter handles\\n- ONLY things that actually HAPPENED today. Not predictions.\\n\\nReturn ONLY valid JSON: {\\\"title\\\": \\\"...\\\", \\\"content\\\": \\\"markdown content\\\", \\\"excerpt\\\": \\\"max 200 chars\\\", \\\"meta_description\\\": \\\"max 160 chars\\\", \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\"]}\",\n    userPrompt: \"Write about: \" + data.topic + \"\\n\\nResearch:\\n\" + (data.summary || \"\") + \"\\n\\nAvailable quotes (paraphrase these inline, do NOT use blockquotes):\\n\" + JSON.stringify(data.key_quotes || []),\n    templateType: data.templateType || \"meme\",\n    topicCategory: data.topicCategory || \"\",\n    sourcesStr: data.sourcesStr || \"\",\n    sourceLinks: data.sourceLinks || [],\n  }\n}];"
            },
            "id": "meme-prompt",
            "name": "Meme Prompt",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                550,
                500
            ]
        },
        {
            "parameters": {
                "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    systemPrompt: \"You are a casual tech writer doing a roundup of today's hottest tech debates. Write a 350-490 word post covering 3-4 spicy topics.\\n\\nWRITING STYLE:\\n- Casual, witty tone \\u2014 like recapping tech discourse for a friend\\n- Use ## headers per topic based on the ACTUAL topic (e.g., \\\"Apple vs EU: Round 47\\\", \\\"The Open-Source AI Licensing Mess\\\")\\n- For each topic: brief setup + the opposing views paraphrased inline (NO blockquotes)\\n- Brief witty commentary between topics \\u2014 take no sides but be entertaining\\n- Bold **key names** and **spicy details**\\n- End with a quick \\\"bottom line\\\" sentence\\n\\nCRITICAL RULES:\\n- Do NOT add a \\\"Sources:\\\" section \\u2014 handled separately\\n- Do NOT mention Doppler VPN or any product\\n- Do NOT fabricate quotes or Twitter handles\\n- ONLY things that actually HAPPENED today. Not forecasts.\\n\\nReturn ONLY valid JSON: {\\\"title\\\": \\\"...\\\", \\\"content\\\": \\\"markdown content\\\", \\\"excerpt\\\": \\\"max 200 chars\\\", \\\"meta_description\\\": \\\"max 160 chars\\\", \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\"]}\",\n    userPrompt: \"Write about: \" + data.topic + \"\\n\\nResearch:\\n\" + (data.summary || \"\") + \"\\n\\nAvailable quotes (paraphrase these inline, do NOT use blockquotes):\\n\" + JSON.stringify(data.key_quotes || []),\n    templateType: data.templateType || \"roundup\",\n    topicCategory: data.topicCategory || \"\",\n    sourcesStr: data.sourcesStr || \"\",\n    sourceLinks: data.sourceLinks || [],\n  }\n}];"
            },
            "id": "roundup-prompt",
            "name": "Roundup Prompt",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                550,
                700
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "https://api.openai.com/v1/chat/completions",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Authorization",
                            "value": "=Bearer {{ $env.OPENAI_API_KEY }}"
                        },
                        {
                            "name": "Content-Type",
                            "value": "application/json"
                        }
                    ]
                },
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={\n  \"model\": \"gpt-5-mini\",\n  \"max_completion_tokens\": 4000,\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": {{ JSON.stringify($json.systemPrompt) }}\n    },\n    {\n      \"role\": \"user\",\n      \"content\": {{ JSON.stringify($json.userPrompt) }}\n    }\n  ]\n}",
                "options": {
                    "timeout": 120000,
                    "response": {
                        "response": {
                            "fullResponse": false,
                            "responseFormat": "json"
                        }
                    }
                }
            },
            "id": "openai-generate",
            "name": "Generate Content",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                850,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "// Parse OpenAI response and extract structured content\nconst response = $input.first().json;\n\n// Safely get previous node data - only one prompt node runs per execution\nlet prevData = {};\nconst promptNodes = ['Quick-Take Prompt', 'Analysis Prompt', 'Meme Prompt', 'Roundup Prompt'];\nfor (const nodeName of promptNodes) {\n  try {\n    const d = $(nodeName).first()?.json;\n    if (d) { prevData = d; break; }\n  } catch (e) {\n    // Node wasn't executed in this run, skip\n  }\n}\n\nlet content;\ntry {\n  const messageContent = response.choices[0].message.content;\n  // Try to extract JSON from the response (might be wrapped in markdown code block)\n  let jsonStr = messageContent;\n  const jsonMatch = messageContent.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[1].trim();\n  }\n  content = JSON.parse(jsonStr);\n} catch (e) {\n  // If JSON parsing fails, use the raw content\n  const raw = response.choices[0].message.content || '';\n  content = {\n    title: 'Untitled Post',\n    content: raw,\n    excerpt: raw.substring(0, 200),\n    meta_description: raw.substring(0, 160),\n    tags: ['tech']\n  };\n}\n\nreturn [{\n  json: {\n    title: content.title || 'Untitled Post',\n    content: content.content || '',\n    excerpt: content.excerpt || '',\n    meta_description: content.meta_description || '',\n    tags: content.tags || ['tech'],\n    templateType: prevData.templateType || '',\n    topicCategory: prevData.topicCategory || '',\n    sourcesStr: prevData.sourcesStr || '',\n    sourceLinks: prevData.sourceLinks || [],\n    model: response.model || 'gpt-5-mini',\n    usage: response.usage || {}\n  }\n}];"
            },
            "id": "parse-content",
            "name": "Parse Content",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1100,
                300
            ]
        },
        {
            "parameters": {
                "jsCode": "// QA cleanup + add max 3 RELEVANT source links\nconst item = $input.first().json;\nlet content = item.content || '';\nconst title = item.title || '';\n\n// 1. Remove any AI-generated Sources sections from content\ncontent = content.replace(/\\n---\\n+\\*\\*Sources?:\\*\\*[\\s\\S]*$/i, '');\ncontent = content.replace(/\\n## Sources?\\n[\\s\\S]*$/i, '');\n\n// 2. Fix duplicate quotes in blockquotes: > \"quote\" -> > quote\ncontent = content.replace(/^(>\\s*)\"(.+)\"(\\s*\u2014)/gm, '$1$2$3');\n\n// 3. Remove excessive newlines\ncontent = content.replace(/\\n{3,}/g, '\\n\\n');\n\n// 4. Extract topic keywords from title for relevance check\nconst topicWords = title.toLowerCase()\n  .split(/[^a-z0-9]+/)\n  .filter(w => w.length > 3 && !['with', 'from', 'that', 'this', 'what', 'when', 'where', 'most', 'more', 'than', 'into', 'over'].includes(w));\n\n// 5. Filter and validate source links\nconst sourceLinks = (item.sourceLinks || [])\n  .filter(link => {\n    const url = typeof link === 'string' ? link : (link && link.url);\n    return url && url !== 'undefined' && url !== '#' && url.startsWith('http');\n  })\n  .map(link => typeof link === 'string' ? link : link.url)\n  .filter((v, i, a) => a.indexOf(v) === i)\n  .slice(0, 3);\n\n// 6. Check relevance - at least one topic keyword must appear in URL\nconst relevantSources = sourceLinks.filter(url => {\n  const lower = url.toLowerCase();\n  // Must have a real article path (not just domain)\n  const path = lower.replace(/^https?:\\/\\/[^/]+/, '');\n  if (path.length < 20) return false;\n  // Check keyword match\n  return topicWords.some(w => lower.includes(w));\n});\n\n// Only add sources section if we have relevant ones\nif (relevantSources.length > 0) {\n  content += '\\n\\n---\\n\\n**Sources:**\\n';\n  for (const url of relevantSources) {\n    const domain = url.replace(/^https?:\\/\\/(?:www\\.)?/, '').split('/')[0];\n    content += '- [' + domain + '](' + url + ')\\n';\n  }\n}\n\nreturn [{\n  json: {\n    title: item.title,\n    content: content.trim(),\n    excerpt: item.excerpt,\n    meta_description: item.meta_description,\n    tags: item.tags,\n    templateType: item.templateType,\n    topicCategory: item.topicCategory,\n    sourcesStr: item.sourcesStr,\n    sourceLinks: relevantSources,\n    model: item.model,\n    usage: item.usage\n  }\n}];"
            },
            "id": "add-sources",
            "name": "Add Source Links",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1350,
                300
            ]
        },
        {
            "parameters": {
                "respondWith": "json",
                "responseBody": "={{ JSON.stringify({ title: $json.title, content: $json.content, excerpt: $json.excerpt, tags: $json.tags, meta_description: $json.meta_description, templateType: $json.templateType, topicCategory: $json.topicCategory, sourcesStr: $json.sourcesStr, sourceLinks: $json.sourceLinks }) }}",
                "options": {}
            },
            "id": "webhook-response",
            "name": "Respond to Webhook",
            "type": "n8n-nodes-base.respondToWebhook",
            "typeVersion": 1.1,
            "position": [
                1600,
                300
            ]
        },
        {
            "id": "flatten-body",
            "name": "Flatten Body",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                480,
                0
            ],
            "parameters": {
                "jsCode": "const items = $input.all();\nconst body = items[0].json.body || items[0].json;\nreturn [{ json: body }];"
            }
        }
    ],
    "connections": {
        "Webhook": {
            "main": [
                [
                    {
                        "node": "Flatten Body",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Template Router": {
            "main": [
                [
                    {
                        "node": "Quick-Take Prompt",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Analysis Prompt",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Meme Prompt",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Roundup Prompt",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Quick-Take Prompt": {
            "main": [
                [
                    {
                        "node": "Generate Content",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Analysis Prompt": {
            "main": [
                [
                    {
                        "node": "Generate Content",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Meme Prompt": {
            "main": [
                [
                    {
                        "node": "Generate Content",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Roundup Prompt": {
            "main": [
                [
                    {
                        "node": "Generate Content",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Generate Content": {
            "main": [
                [
                    {
                        "node": "Parse Content",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Parse Content": {
            "main": [
                [
                    {
                        "node": "Add Source Links",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Add Source Links": {
            "main": [
                [
                    {
                        "node": "Respond to Webhook",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Flatten Body": {
            "main": [
                [
                    {
                        "node": "Template Router",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1",
        "callerPolicy": "workflowsFromSameOwner",
        "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "94151079-fb3d-4d3d-a7ba-bfa54944c605",
    "activeVersionId": "94151079-fb3d-4d3d-a7ba-bfa54944c605",
    "versionCounter": 44,
    "triggerCount": 1,
    "shared": [
        {
            "updatedAt": "2026-02-26T00:04:59.802Z",
            "createdAt": "2026-02-26T00:04:59.802Z",
            "role": "workflow:owner",
            "workflowId": "CoWsngJ0UMOjyzFL",
            "projectId": "EONlUm0d92HHHVBN",
            "project": {
                "updatedAt": "2026-02-25T02:05:40.807Z",
                "createdAt": "2026-02-15T17:41:33.246Z",
                "id": "EONlUm0d92HHHVBN",
                "name": "Roman Pochtman <pochtmanrca@gmail.com>",
                "type": "personal",
                "icon": null,
                "description": null,
                "creatorId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                "projectRelations": [
                    {
                        "updatedAt": "2026-02-15T17:41:33.246Z",
                        "createdAt": "2026-02-15T17:41:33.246Z",
                        "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                        "projectId": "EONlUm0d92HHHVBN",
                        "user": {
                            "updatedAt": "2026-02-26T00:55:17.000Z",
                            "createdAt": "2026-02-25T01:40:25.011Z",
                            "id": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                            "email": "pochtmanrca@gmail.com",
                            "firstName": "Roman",
                            "lastName": "Pochtman",
                            "personalizationAnswers": null,
                            "settings": {
                                "firstSuccessfulWorkflowId": "CoWsngJ0UMOjyzFL",
                                "userActivated": true,
                                "userActivatedAt": 1772064788001
                            },
                            "disabled": false,
                            "mfaEnabled": false,
                            "lastActiveAt": "2026-02-25",
                            "isPending": false
                        }
                    }
                ]
            }
        }
    ],
    "tags": [],
    "activeVersion": {
        "updatedAt": "2026-02-26T02:23:45.745Z",
        "createdAt": "2026-02-26T02:23:45.745Z",
        "versionId": "94151079-fb3d-4d3d-a7ba-bfa54944c605",
        "workflowId": "CoWsngJ0UMOjyzFL",
        "nodes": [
            {
                "parameters": {
                    "httpMethod": "POST",
                    "path": "doppler-content-gen",
                    "responseMode": "responseNode",
                    "options": {}
                },
                "id": "webhook-trigger",
                "name": "Webhook",
                "type": "n8n-nodes-base.webhook",
                "typeVersion": 2,
                "position": [
                    0,
                    300
                ],
                "webhookId": "doppler-content-gen"
            },
            {
                "parameters": {
                    "rules": {
                        "values": [
                            {
                                "conditions": {
                                    "options": {
                                        "caseSensitive": false,
                                        "leftValue": "",
                                        "typeValidation": "strict"
                                    },
                                    "conditions": [
                                        {
                                            "leftValue": "={{ $json.templateType }}",
                                            "rightValue": "quick-take",
                                            "operator": {
                                                "type": "string",
                                                "operation": "equals"
                                            }
                                        }
                                    ],
                                    "combinator": "and"
                                },
                                "renameOutput": true,
                                "outputLabel": "quick-take"
                            },
                            {
                                "conditions": {
                                    "options": {
                                        "caseSensitive": false,
                                        "leftValue": "",
                                        "typeValidation": "strict"
                                    },
                                    "conditions": [
                                        {
                                            "leftValue": "={{ $json.templateType }}",
                                            "rightValue": "analysis",
                                            "operator": {
                                                "type": "string",
                                                "operation": "equals"
                                            }
                                        }
                                    ],
                                    "combinator": "and"
                                },
                                "renameOutput": true,
                                "outputLabel": "analysis"
                            },
                            {
                                "conditions": {
                                    "options": {
                                        "caseSensitive": false,
                                        "leftValue": "",
                                        "typeValidation": "strict"
                                    },
                                    "conditions": [
                                        {
                                            "leftValue": "={{ $json.templateType }}",
                                            "rightValue": "meme",
                                            "operator": {
                                                "type": "string",
                                                "operation": "equals"
                                            }
                                        }
                                    ],
                                    "combinator": "and"
                                },
                                "renameOutput": true,
                                "outputLabel": "meme"
                            },
                            {
                                "conditions": {
                                    "options": {
                                        "caseSensitive": false,
                                        "leftValue": "",
                                        "typeValidation": "strict"
                                    },
                                    "conditions": [
                                        {
                                            "leftValue": "={{ $json.templateType }}",
                                            "rightValue": "roundup",
                                            "operator": {
                                                "type": "string",
                                                "operation": "equals"
                                            }
                                        }
                                    ],
                                    "combinator": "and"
                                },
                                "renameOutput": true,
                                "outputLabel": "roundup"
                            }
                        ]
                    },
                    "options": {
                        "fallbackOutput": "extra"
                    }
                },
                "id": "template-router",
                "name": "Template Router",
                "type": "n8n-nodes-base.switch",
                "typeVersion": 3.2,
                "position": [
                    250,
                    300
                ]
            },
            {
                "parameters": {
                    "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    systemPrompt: \"You are a policy analyst writing for a tech blog. Write a 280-420 word news article about a REAL event that happened today.\\n\\nWRITING STYLE:\\n- Natural flowing prose \\u2014 NO rigid template sections like \\\"What happened\\\", \\\"Quotes\\\", \\\"Why it matters\\\"\\n- Use ## headers based on THE ACTUAL TOPIC (e.g., \\\"The 48-Hour Rule and Why It Matters\\\", \\\"Broader Regulatory Fallout\\\") \\u2014 NEVER generic labels\\n- Inline citations as [1], [2] within sentences naturally\\n- Bold **key terms** strategically (names, numbers, deadlines, laws)\\n- Mix short punchy sentences with longer explanatory ones\\n- Authoritative but accessible \\u2014 like a policy analyst writing for smart readers\\n- NO blockquote quotes. If quotes exist, paraphrase inline: \\\"as one analyst noted, ...\\\" or \\\"according to [Name], ...\\\"\\n- Weave in a privacy/VPN angle ONLY if genuinely relevant to the story \\u2014 never force it\\n- End with 2-3 sentences of practical implications for readers\\n\\nCRITICAL RULES:\\n- Do NOT add a \\\"Sources:\\\" section \\u2014 handled separately\\n- Do NOT mention Doppler VPN or any product\\n- Do NOT fabricate quotes, Twitter handles, or attributions\\n- Do NOT use formulaic AI patterns like \\\"In a landmark move...\\\" or \\\"This is a wake-up call...\\\"\\n- ONLY cover events that actually HAPPENED (announced, signed, launched, leaked). No predictions or forecasts.\\n\\nReturn ONLY valid JSON: {\\\"title\\\": \\\"...\\\", \\\"content\\\": \\\"markdown content\\\", \\\"excerpt\\\": \\\"max 200 chars\\\", \\\"meta_description\\\": \\\"max 160 chars\\\", \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\"]}\",\n    userPrompt: \"Write about: \" + data.topic + \"\\n\\nResearch:\\n\" + (data.summary || \"\") + \"\\n\\nAvailable quotes (paraphrase these inline, do NOT use blockquotes):\\n\" + JSON.stringify(data.key_quotes || []),\n    templateType: data.templateType || \"quick-take\",\n    topicCategory: data.topicCategory || \"\",\n    sourcesStr: data.sourcesStr || \"\",\n    sourceLinks: data.sourceLinks || [],\n  }\n}];"
                },
                "id": "quick-take-prompt",
                "name": "Quick-Take Prompt",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    550,
                    100
                ]
            },
            {
                "parameters": {
                    "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    systemPrompt: \"You are a policy analyst writing for a tech blog. Write a 560-840 word analysis piece about a REAL event that happened today.\\n\\nWRITING STYLE:\\n- Natural flowing prose across multiple ## sections with TOPIC-SPECIFIC headers (e.g., \\\"The Rise of AI-Assisted Abuse\\\", \\\"Expert Analysis: Compliance as Competitive Edge\\\")\\n- NEVER use generic headers like \\\"What happened\\\", \\\"Context\\\", \\\"Quotes\\\", \\\"Analysis\\\"\\n- Inline citations as [1], [2] within sentences naturally\\n- Bold **key terms** strategically (names, numbers, deadlines, laws, companies)\\n- Mix of short punchy sentences and longer explanatory ones\\n- Authoritative but accessible \\u2014 like a policy analyst explaining to smart readers\\n- NO blockquote quotes. Paraphrase: \\\"Legal experts at [Firm] predict...\\\" or \\\"as [Name] noted in a recent report...\\\"\\n- Include a comparative table if multiple regulations/companies/events are being contrasted (use markdown tables)\\n- Include a practical advice section near the end with concrete actionable steps for individuals and businesses\\n- Weave in a privacy/VPN angle ONLY if genuinely relevant \\u2014 never force it\\n\\nCRITICAL RULES:\\n- Do NOT add a \\\"Sources:\\\" section \\u2014 handled separately\\n- Do NOT mention Doppler VPN or any product\\n- Do NOT fabricate quotes, Twitter handles, or attributions\\n- Do NOT use formulaic AI patterns like \\\"In a landmark move...\\\" or \\\"This is a wake-up call...\\\"\\n- ONLY cover events that actually HAPPENED. No predictions or \\\"poised to\\\" language.\\n\\nReturn ONLY valid JSON: {\\\"title\\\": \\\"...\\\", \\\"content\\\": \\\"markdown content\\\", \\\"excerpt\\\": \\\"max 200 chars\\\", \\\"meta_description\\\": \\\"max 160 chars\\\", \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\"]}\",\n    userPrompt: \"Write about: \" + data.topic + \"\\n\\nResearch:\\n\" + (data.summary || \"\") + \"\\n\\nAvailable quotes (paraphrase these inline, do NOT use blockquotes):\\n\" + JSON.stringify(data.key_quotes || []),\n    templateType: data.templateType || \"analysis\",\n    topicCategory: data.topicCategory || \"\",\n    sourcesStr: data.sourcesStr || \"\",\n    sourceLinks: data.sourceLinks || [],\n  }\n}];"
                },
                "id": "analysis-prompt",
                "name": "Analysis Prompt",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    550,
                    300
                ]
            },
            {
                "parameters": {
                    "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    systemPrompt: \"You are a casual tech writer covering a viral moment. Write a 210-280 word post about something that blew up online today.\\n\\nWRITING STYLE:\\n- Casual, conversational tone \\u2014 like explaining drama to a friend\\n- One fun ## header or none at all \\u2014 this is a short post\\n- Keep it tight: what happened, why people care, the best reactions\\n- NO blockquote quotes. Paraphrase reactions inline: \\\"one dev quipped that...\\\" or \\\"the internet collectively lost it when...\\\"\\n- Internet humor welcome but don't try too hard\\n- Bold the **key moment** or **spicy detail**\\n- End with a witty one-liner or quick take\\n\\nCRITICAL RULES:\\n- Do NOT add a \\\"Sources:\\\" section \\u2014 handled separately\\n- Do NOT mention Doppler VPN or any product\\n- Do NOT fabricate quotes or Twitter handles\\n- ONLY things that actually HAPPENED today. Not predictions.\\n\\nReturn ONLY valid JSON: {\\\"title\\\": \\\"...\\\", \\\"content\\\": \\\"markdown content\\\", \\\"excerpt\\\": \\\"max 200 chars\\\", \\\"meta_description\\\": \\\"max 160 chars\\\", \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\"]}\",\n    userPrompt: \"Write about: \" + data.topic + \"\\n\\nResearch:\\n\" + (data.summary || \"\") + \"\\n\\nAvailable quotes (paraphrase these inline, do NOT use blockquotes):\\n\" + JSON.stringify(data.key_quotes || []),\n    templateType: data.templateType || \"meme\",\n    topicCategory: data.topicCategory || \"\",\n    sourcesStr: data.sourcesStr || \"\",\n    sourceLinks: data.sourceLinks || [],\n  }\n}];"
                },
                "id": "meme-prompt",
                "name": "Meme Prompt",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    550,
                    500
                ]
            },
            {
                "parameters": {
                    "jsCode": "const data = $input.first().json;\n\nreturn [{\n  json: {\n    systemPrompt: \"You are a casual tech writer doing a roundup of today's hottest tech debates. Write a 350-490 word post covering 3-4 spicy topics.\\n\\nWRITING STYLE:\\n- Casual, witty tone \\u2014 like recapping tech discourse for a friend\\n- Use ## headers per topic based on the ACTUAL topic (e.g., \\\"Apple vs EU: Round 47\\\", \\\"The Open-Source AI Licensing Mess\\\")\\n- For each topic: brief setup + the opposing views paraphrased inline (NO blockquotes)\\n- Brief witty commentary between topics \\u2014 take no sides but be entertaining\\n- Bold **key names** and **spicy details**\\n- End with a quick \\\"bottom line\\\" sentence\\n\\nCRITICAL RULES:\\n- Do NOT add a \\\"Sources:\\\" section \\u2014 handled separately\\n- Do NOT mention Doppler VPN or any product\\n- Do NOT fabricate quotes or Twitter handles\\n- ONLY things that actually HAPPENED today. Not forecasts.\\n\\nReturn ONLY valid JSON: {\\\"title\\\": \\\"...\\\", \\\"content\\\": \\\"markdown content\\\", \\\"excerpt\\\": \\\"max 200 chars\\\", \\\"meta_description\\\": \\\"max 160 chars\\\", \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\"]}\",\n    userPrompt: \"Write about: \" + data.topic + \"\\n\\nResearch:\\n\" + (data.summary || \"\") + \"\\n\\nAvailable quotes (paraphrase these inline, do NOT use blockquotes):\\n\" + JSON.stringify(data.key_quotes || []),\n    templateType: data.templateType || \"roundup\",\n    topicCategory: data.topicCategory || \"\",\n    sourcesStr: data.sourcesStr || \"\",\n    sourceLinks: data.sourceLinks || [],\n  }\n}];"
                },
                "id": "roundup-prompt",
                "name": "Roundup Prompt",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    550,
                    700
                ]
            },
            {
                "parameters": {
                    "method": "POST",
                    "url": "https://api.openai.com/v1/chat/completions",
                    "sendHeaders": true,
                    "headerParameters": {
                        "parameters": [
                            {
                                "name": "Authorization",
                                "value": "=Bearer {{ $env.OPENAI_API_KEY }}"
                            },
                            {
                                "name": "Content-Type",
                                "value": "application/json"
                            }
                        ]
                    },
                    "sendBody": true,
                    "specifyBody": "json",
                    "jsonBody": "={\n  \"model\": \"gpt-5-mini\",\n  \"max_completion_tokens\": 4000,\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": {{ JSON.stringify($json.systemPrompt) }}\n    },\n    {\n      \"role\": \"user\",\n      \"content\": {{ JSON.stringify($json.userPrompt) }}\n    }\n  ]\n}",
                    "options": {
                        "timeout": 120000,
                        "response": {
                            "response": {
                                "fullResponse": false,
                                "responseFormat": "json"
                            }
                        }
                    }
                },
                "id": "openai-generate",
                "name": "Generate Content",
                "type": "n8n-nodes-base.httpRequest",
                "typeVersion": 4.2,
                "position": [
                    850,
                    300
                ]
            },
            {
                "parameters": {
                    "jsCode": "// Parse OpenAI response and extract structured content\nconst response = $input.first().json;\n\n// Safely get previous node data - only one prompt node runs per execution\nlet prevData = {};\nconst promptNodes = ['Quick-Take Prompt', 'Analysis Prompt', 'Meme Prompt', 'Roundup Prompt'];\nfor (const nodeName of promptNodes) {\n  try {\n    const d = $(nodeName).first()?.json;\n    if (d) { prevData = d; break; }\n  } catch (e) {\n    // Node wasn't executed in this run, skip\n  }\n}\n\nlet content;\ntry {\n  const messageContent = response.choices[0].message.content;\n  // Try to extract JSON from the response (might be wrapped in markdown code block)\n  let jsonStr = messageContent;\n  const jsonMatch = messageContent.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[1].trim();\n  }\n  content = JSON.parse(jsonStr);\n} catch (e) {\n  // If JSON parsing fails, use the raw content\n  const raw = response.choices[0].message.content || '';\n  content = {\n    title: 'Untitled Post',\n    content: raw,\n    excerpt: raw.substring(0, 200),\n    meta_description: raw.substring(0, 160),\n    tags: ['tech']\n  };\n}\n\nreturn [{\n  json: {\n    title: content.title || 'Untitled Post',\n    content: content.content || '',\n    excerpt: content.excerpt || '',\n    meta_description: content.meta_description || '',\n    tags: content.tags || ['tech'],\n    templateType: prevData.templateType || '',\n    topicCategory: prevData.topicCategory || '',\n    sourcesStr: prevData.sourcesStr || '',\n    sourceLinks: prevData.sourceLinks || [],\n    model: response.model || 'gpt-5-mini',\n    usage: response.usage || {}\n  }\n}];"
                },
                "id": "parse-content",
                "name": "Parse Content",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1100,
                    300
                ]
            },
            {
                "parameters": {
                    "jsCode": "// QA cleanup + add max 3 RELEVANT source links\nconst item = $input.first().json;\nlet content = item.content || '';\nconst title = item.title || '';\n\n// 1. Remove any AI-generated Sources sections from content\ncontent = content.replace(/\\n---\\n+\\*\\*Sources?:\\*\\*[\\s\\S]*$/i, '');\ncontent = content.replace(/\\n## Sources?\\n[\\s\\S]*$/i, '');\n\n// 2. Fix duplicate quotes in blockquotes: > \"quote\" -> > quote\ncontent = content.replace(/^(>\\s*)\"(.+)\"(\\s*\u2014)/gm, '$1$2$3');\n\n// 3. Remove excessive newlines\ncontent = content.replace(/\\n{3,}/g, '\\n\\n');\n\n// 4. Extract topic keywords from title for relevance check\nconst topicWords = title.toLowerCase()\n  .split(/[^a-z0-9]+/)\n  .filter(w => w.length > 3 && !['with', 'from', 'that', 'this', 'what', 'when', 'where', 'most', 'more', 'than', 'into', 'over'].includes(w));\n\n// 5. Filter and validate source links\nconst sourceLinks = (item.sourceLinks || [])\n  .filter(link => {\n    const url = typeof link === 'string' ? link : (link && link.url);\n    return url && url !== 'undefined' && url !== '#' && url.startsWith('http');\n  })\n  .map(link => typeof link === 'string' ? link : link.url)\n  .filter((v, i, a) => a.indexOf(v) === i)\n  .slice(0, 3);\n\n// 6. Check relevance - at least one topic keyword must appear in URL\nconst relevantSources = sourceLinks.filter(url => {\n  const lower = url.toLowerCase();\n  // Must have a real article path (not just domain)\n  const path = lower.replace(/^https?:\\/\\/[^/]+/, '');\n  if (path.length < 20) return false;\n  // Check keyword match\n  return topicWords.some(w => lower.includes(w));\n});\n\n// Only add sources section if we have relevant ones\nif (relevantSources.length > 0) {\n  content += '\\n\\n---\\n\\n**Sources:**\\n';\n  for (const url of relevantSources) {\n    const domain = url.replace(/^https?:\\/\\/(?:www\\.)?/, '').split('/')[0];\n    content += '- [' + domain + '](' + url + ')\\n';\n  }\n}\n\nreturn [{\n  json: {\n    title: item.title,\n    content: content.trim(),\n    excerpt: item.excerpt,\n    meta_description: item.meta_description,\n    tags: item.tags,\n    templateType: item.templateType,\n    topicCategory: item.topicCategory,\n    sourcesStr: item.sourcesStr,\n    sourceLinks: relevantSources,\n    model: item.model,\n    usage: item.usage\n  }\n}];"
                },
                "id": "add-sources",
                "name": "Add Source Links",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1350,
                    300
                ]
            },
            {
                "parameters": {
                    "respondWith": "json",
                    "responseBody": "={{ JSON.stringify({ title: $json.title, content: $json.content, excerpt: $json.excerpt, tags: $json.tags, meta_description: $json.meta_description, templateType: $json.templateType, topicCategory: $json.topicCategory, sourcesStr: $json.sourcesStr, sourceLinks: $json.sourceLinks }) }}",
                    "options": {}
                },
                "id": "webhook-response",
                "name": "Respond to Webhook",
                "type": "n8n-nodes-base.respondToWebhook",
                "typeVersion": 1.1,
                "position": [
                    1600,
                    300
                ]
            },
            {
                "id": "flatten-body",
                "name": "Flatten Body",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    480,
                    0
                ],
                "parameters": {
                    "jsCode": "const items = $input.all();\nconst body = items[0].json.body || items[0].json;\nreturn [{ json: body }];"
                }
            }
        ],
        "connections": {
            "Webhook": {
                "main": [
                    [
                        {
                            "node": "Flatten Body",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Template Router": {
                "main": [
                    [
                        {
                            "node": "Quick-Take Prompt",
                            "type": "main",
                            "index": 0
                        }
                    ],
                    [
                        {
                            "node": "Analysis Prompt",
                            "type": "main",
                            "index": 0
                        }
                    ],
                    [
                        {
                            "node": "Meme Prompt",
                            "type": "main",
                            "index": 0
                        }
                    ],
                    [
                        {
                            "node": "Roundup Prompt",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Quick-Take Prompt": {
                "main": [
                    [
                        {
                            "node": "Generate Content",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Analysis Prompt": {
                "main": [
                    [
                        {
                            "node": "Generate Content",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Meme Prompt": {
                "main": [
                    [
                        {
                            "node": "Generate Content",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Roundup Prompt": {
                "main": [
                    [
                        {
                            "node": "Generate Content",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Generate Content": {
                "main": [
                    [
                        {
                            "node": "Parse Content",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Parse Content": {
                "main": [
                    [
                        {
                            "node": "Add Source Links",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Add Source Links": {
                "main": [
                    [
                        {
                            "node": "Respond to Webhook",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Flatten Body": {
                "main": [
                    [
                        {
                            "node": "Template Router",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            }
        },
        "authors": "Roman Pochtman",
        "name": null,
        "description": null,
        "autosaved": false,
        "workflowPublishHistory": [
            {
                "createdAt": "2026-02-26T02:23:45.802Z",
                "id": 166,
                "workflowId": "CoWsngJ0UMOjyzFL",
                "versionId": "94151079-fb3d-4d3d-a7ba-bfa54944c605",
                "event": "activated",
                "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039"
            }
        ]
    }
}
