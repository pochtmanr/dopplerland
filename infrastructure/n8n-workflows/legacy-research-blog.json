{
    "updatedAt": "2026-02-25T23:10:56.244Z",
    "createdAt": "2026-02-21T19:15:19.007Z",
    "id": "e3eZTcjR5Ir7Zwgw",
    "name": "Doppler Research + Blog Creation",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
        {
            "parameters": {
                "rule": {
                    "interval": [
                        {
                            "field": "hours",
                            "hoursInterval": 72
                        }
                    ]
                }
            },
            "id": "schedule-trigger",
            "name": "Schedule (Every 3 Days)",
            "type": "n8n-nodes-base.scheduleTrigger",
            "typeVersion": 1.2,
            "position": [
                0,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsGet(hostname, path, headers) {\n  return new Promise((resolve, reject) => {\n    const opts = { hostname, path, method: 'GET', headers: headers || {} };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.end();\n  });\n}\n\nconst supabaseHost = $env.SUPABASE_URL.replace('https://', '');\nconst serviceKey = $env.SUPABASE_SERVICE_KEY;\nconst authHeaders = { 'Authorization': 'Bearer ' + serviceKey, 'apikey': serviceKey };\n\nlet recentTitles = [];\ntry {\n  const postsRes = await httpsGet(supabaseHost, '/rest/v1/blog_posts?select=id&order=created_at.desc&limit=5', authHeaders);\n  if (postsRes.status === 200) {\n    const posts = JSON.parse(postsRes.body);\n    for (const post of posts) {\n      const tRes = await httpsGet(supabaseHost, '/rest/v1/blog_post_translations?post_id=eq.' + post.id + '&locale=eq.en&select=title&limit=1', authHeaders);\n      if (tRes.status === 200) {\n        const tData = JSON.parse(tRes.body);\n        if (tData[0] && tData[0].title) recentTitles.push(tData[0].title);\n      }\n    }\n  }\n} catch (e) {}\n\nconst categories = [\n  'VPN technology, protocols, and online privacy tools',\n  'Cybersecurity threats, data breaches, and malware news',\n  'Internet censorship, country-level restrictions, and access to information',\n  'AI and tech startup developments affecting digital privacy',\n  'New privacy-focused apps, services, browsers, and tools',\n  'Tech regulation, antitrust actions, and data protection laws',\n  'Open source security tools and developer privacy resources',\n  'Digital rights, government surveillance, and whistleblower news'\n];\n\nconst hoursSinceEpoch = Math.floor(Date.now() / (1000 * 60 * 60));\nconst categoryIndex = hoursSinceEpoch % categories.length;\nconst focusCategory = categories[categoryIndex];\n\nreturn [{ json: { recentTitles, focusCategory, categoryIndex } }];"
            },
            "id": "fetch-recent",
            "name": "Fetch Recent Posts",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                250,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(60000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst recentTitles = $json.recentTitles || [];\nconst focusCategory = $json.focusCategory;\nconst perplexityKey = $env.PERPLEXITY_API_KEY;\n\nconst exclusionText = recentTitles.length > 0\n  ? '\\n\\nIMPORTANT \\u2014 DO NOT write about these topics, they were already covered recently:\\n' + recentTitles.map((t, i) => (i+1) + '. ' + t).join('\\n') + '\\n\\nPick a COMPLETELY DIFFERENT topic from any of the above.'\n  : '';\n\nconst systemContent = 'You are a senior tech journalist writing for Doppler VPN blog. Your audience is tech-savvy users who care about online privacy, security, and digital freedom.\\n\\nToday focus area: ' + focusCategory + '\\n\\nBROAD TOPIC SCOPE \\u2014 you may write about ANY of these areas:\\n- VPN technology, protocols, and online privacy\\n- Cybersecurity news, data breaches, and emerging threats\\n- Internet censorship and country-level access restrictions\\n- AI developments that affect privacy and security\\n- New privacy-focused apps, tools, browsers, and services\\n- Tech regulation, antitrust, and data protection laws (GDPR, etc.)\\n- Open source security tools and developer resources\\n- Digital rights, surveillance, and whistleblower stories\\n- Encrypted messaging and secure communication\\n- Cloud security and enterprise privacy' + exclusionText + '\\n\\nRequirements:\\n- Find a TRENDING, RECENT topic from the last 7 days (not evergreen content)\\n- Write 800-1200 words, SEO-optimized\\n- Use markdown headers (## and ###) and paragraphs\\n- Include practical advice for readers\\n- Start with a compelling H1 title on the first line (# Title)\\n- Be factual and cite your sources';\n\nconst userContent = 'Write a comprehensive blog post about a trending topic in: ' + focusCategory + '. Focus on the most newsworthy development from the past week. Include recent events, expert analysis, and actionable advice for readers.';\n\nconst res = await httpsPost('api.perplexity.ai', '/chat/completions', {\n  'Authorization': 'Bearer ' + perplexityKey\n}, {\n  model: 'sonar',\n  messages: [\n    { role: 'system', content: systemContent },\n    { role: 'user', content: userContent }\n  ],\n  max_tokens: 2000,\n  temperature: 0.7\n});\n\nif (res.status !== 200) {\n  throw new Error('Perplexity failed (' + res.status + '): ' + res.body.slice(0, 300));\n}\n\nconst data = JSON.parse(res.body);\nreturn [{ json: data }];"
            },
            "id": "perplexity-research",
            "name": "Perplexity Research",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                500,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const urlMod = require('url');\n\nconst response = $input.first().json;\nconst content = response.choices?.[0]?.message?.content || '';\nconst citations = response.citations || [];\n\nlet title = '';\nlet body = content;\n\nconst titleMatch = content.match(/^#\\s+(.+)$/m);\nif (titleMatch) {\n  title = titleMatch[1].trim();\n  body = content.replace(/^#\\s+.+$/m, '').trim();\n} else {\n  const lines = content.split('\\n').filter(l => l.trim());\n  title = lines[0] ? lines[0].replace(/^[#*]+\\s*/, '').trim() : 'Tech Security Update';\n  body = lines.slice(1).join('\\n').trim();\n}\n\nconst slug = title\n  .toLowerCase()\n  .replace(/[^a-z0-9\\s-]/g, '')\n  .replace(/\\s+/g, '-')\n  .replace(/-+/g, '-')\n  .slice(0, 80);\n\nconst plainBody = body.replace(/[#*_~`>\\[\\]()]/g, '').trim();\nconst excerpt = plainBody.slice(0, 200).trim() + '...';\nconst meta_description = plainBody.slice(0, 160).trim();\n\nconst source_links = citations.map(citUrl => {\n  try {\n    const parsed = urlMod.parse(citUrl);\n    const hostname = (parsed.hostname || '').replace('www.', '');\n    return { text: hostname, url: citUrl };\n  } catch (e) { return { text: citUrl, url: citUrl }; }\n}).filter(s => s.url);\n\nconst lowerTitle = title.toLowerCase();\nconst combined = lowerTitle + ' ' + body.toLowerCase().slice(0, 2000);\n\nconst tagRules = [\n  { tag: 'vpn', keywords: ['vpn', 'wireguard', 'openvpn', 'tunnel', 'proxy'] },\n  { tag: 'privacy', keywords: ['privacy', 'private', 'tracking', 'surveillance', 'gdpr', 'data protection'] },\n  { tag: 'cybersecurity', keywords: ['cyber', 'hack', 'breach', 'malware', 'ransomware', 'phishing', 'vulnerability'] },\n  { tag: 'ai', keywords: ['artificial intelligence', ' ai ', 'machine learning', 'deepfake', 'chatgpt', 'llm'] },\n  { tag: 'censorship', keywords: ['censor', 'blocked', 'restriction', 'firewall', 'banned', 'internet freedom'] },\n  { tag: 'regulation', keywords: ['regulation', 'law', 'legislation', 'antitrust', 'gdpr', 'compliance'] },\n  { tag: 'encryption', keywords: ['encrypt', 'end-to-end', 'e2ee', 'cryptograph', 'ssl', 'tls'] },\n  { tag: 'data-breach', keywords: ['breach', 'leaked', 'exposed', 'compromised', 'stolen data'] },\n  { tag: 'open-source', keywords: ['open source', 'open-source', 'github', 'foss'] },\n  { tag: 'apps', keywords: ['app ', 'browser', 'extension', 'tool', 'software'] }\n];\n\nconst tags = tagRules.filter(r => r.keywords.some(kw => combined.includes(kw))).map(r => r.tag).slice(0, 5);\nif (tags.length === 0) tags.push('tech-news');\n\nreturn [{ json: { title, slug: slug + '-' + Date.now().toString(36), content: body, excerpt, meta_description, source_links, tags, auto_translate: false, author: 'Doppler VPN' } }];"
            },
            "id": "format-content",
            "name": "Format Blog Content",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                750,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(30000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst apiKey = $env.BLOG_API_KEY;\nconst d = $json;\n\nconst res = await httpsPost('www.dopplervpn.org', '/api/blog/create', {\n  'Authorization': apiKey\n}, {\n  title: d.title,\n  content: d.content,\n  slug: d.slug,\n  excerpt: d.excerpt,\n  meta_description: d.meta_description,\n  source_links: d.source_links,\n  tags: d.tags,\n  auto_translate: false,\n  author: d.author\n});\n\nif (res.status !== 200 && res.status !== 201) {\n  throw new Error('Blog create failed (' + res.status + '): ' + res.body.slice(0, 500));\n}\n\nconst result = JSON.parse(res.body);\nreturn [{ json: { slug: result.slug || d.slug, blog_id: result.blog_id, ...result } }];"
            },
            "id": "create-blog",
            "name": "Create Blog Post",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1000,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const http = require('http');\n\nfunction httpPost(hostname, port, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, port, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = http.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(120000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst slug = $json.slug || $('Format Blog Content').first().json.slug;\nconst title = $('Format Blog Content').first().json.title;\nconst content = $('Format Blog Content').first().json.content;\nconst tags = $('Format Blog Content').first().json.tags;\n\nconst res = await httpPost('127.0.0.1', 5678, '/webhook/find-image', {}, { slug, title, content, tags });\n\nlet result = { success: false };\ntry { result = JSON.parse(res.body); } catch (e) {}\nreturn [{ json: { ...result, slug } }];"
            },
            "id": "find-image",
            "name": "Find Image",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1250,
                0
            ],
            "continueOnFail": true
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(600000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst slug = $('Create Blog Post').first().json.slug || $('Format Blog Content').first().json.slug;\n\nif (!slug || typeof slug !== 'string' || slug.trim() === '') {\n  throw new Error('No valid slug found from Create Blog Post or Format Blog Content nodes');\n}\n\nconst apiKey = $env.BLOG_API_KEY;\nif (!apiKey) {\n  throw new Error('BLOG_API_KEY environment variable is not set');\n}\n\n// Call the translate API which handles all languages (parallelized server-side)\nconst res = await httpsPost('www.dopplervpn.org', '/api/blog/translate', {\n  'Authorization': apiKey\n}, { slug });\n\nif (res.status !== 200 && res.status !== 201) {\n  throw new Error('Translate failed (' + res.status + '): ' + res.body.slice(0, 500));\n}\n\nconst result = JSON.parse(res.body);\nreturn [{ json: { slug, translated: result.translated || [], total_translated: (result.translated || []).length, errors: result.errors || [] } }];"
            },
            "id": "translate-all",
            "name": "Translate All Languages",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1500,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const http = require('http');\n\nfunction httpPost(hostname, port, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, port, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = http.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(30000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst slug = $('Create Blog Post').first().json.slug || $('Format Blog Content').first().json.slug;\n\nconst res = await httpPost('127.0.0.1', 5678, '/webhook/post-to-channels', {}, { slug });\n\nlet result = { success: false };\ntry { result = JSON.parse(res.body); } catch (e) {}\nreturn [{ json: result }];"
            },
            "id": "post-channels",
            "name": "Post to Channels",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1750,
                0
            ],
            "continueOnFail": true
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\nconst botToken = $env.TELEGRAM_BOT_TOKEN;\nconst slug = $('Create Blog Post').first().json.slug || $('Format Blog Content').first().json.slug;\nconst title = $('Format Blog Content').first().json.title;\nconst imageSuccess = $('Find Image').first().json.success;\nconst totalTranslated = $('Translate All Languages').first().json.total_translated || 0;\nconst channelSuccess = $('Post to Channels').first().json.success;\n\nconst text = '\\ud83d\\udcdd Blog post pipeline complete!\\n\\n\\ud83d\\udcf0 ' + title + '\\n\\ud83d\\uddbc Image: ' + (imageSuccess ? '\\u2705 Generated' : '\\u274c Failed') + '\\n\\ud83c\\udf10 Translations: ' + totalTranslated + '\\n\\ud83d\\udce2 Channels: ' + (channelSuccess ? '\\u2705 Posted' : '\\u26a0\\ufe0f Check manually') + '\\n\\n\\ud83d\\udd17 https://www.dopplervpn.org/en/blog/' + slug + '\\n\\n\\u270f\\ufe0f Edit: https://www.dopplervpn.org/admin-dvpn';\n\nawait httpsPost('api.telegram.org', '/bot' + botToken + '/sendMessage', {}, {\n  chat_id: 218545546,\n  text: text,\n  parse_mode: 'HTML'\n});\n\nreturn [{ json: { notified: true, slug } }];"
            },
            "id": "notify-admin",
            "name": "Notify Roman",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                2000,
                0
            ]
        }
    ],
    "connections": {
        "Schedule (Every 3 Days)": {
            "main": [
                [
                    {
                        "node": "Fetch Recent Posts",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Fetch Recent Posts": {
            "main": [
                [
                    {
                        "node": "Perplexity Research",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Perplexity Research": {
            "main": [
                [
                    {
                        "node": "Format Blog Content",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Format Blog Content": {
            "main": [
                [
                    {
                        "node": "Create Blog Post",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Create Blog Post": {
            "main": [
                [
                    {
                        "node": "Find Image",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Find Image": {
            "main": [
                [
                    {
                        "node": "Translate All Languages",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Translate All Languages": {
            "main": [
                [
                    {
                        "node": "Post to Channels",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Post to Channels": {
            "main": [
                [
                    {
                        "node": "Notify Roman",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1",
        "callerPolicy": "workflowsFromSameOwner",
        "availableInMCP": false
    },
    "staticData": {
        "node:Schedule (3x Daily)": {
            "recurrenceRules": [
                16
            ]
        },
        "node:Schedule (Every 3 Days)": {
            "recurrenceRules": [
                0
            ]
        }
    },
    "meta": null,
    "pinData": null,
    "versionId": "917dbfb7-18e0-49c5-b6a5-1187789ccb25",
    "activeVersionId": "917dbfb7-18e0-49c5-b6a5-1187789ccb25",
    "versionCounter": 85,
    "triggerCount": 1,
    "shared": [
        {
            "updatedAt": "2026-02-21T19:15:19.014Z",
            "createdAt": "2026-02-21T19:15:19.014Z",
            "role": "workflow:owner",
            "workflowId": "e3eZTcjR5Ir7Zwgw",
            "projectId": "EONlUm0d92HHHVBN",
            "project": {
                "updatedAt": "2026-02-25T02:05:40.807Z",
                "createdAt": "2026-02-15T17:41:33.246Z",
                "id": "EONlUm0d92HHHVBN",
                "name": "Roman Pochtman <pochtmanrca@gmail.com>",
                "type": "personal",
                "icon": null,
                "description": null,
                "creatorId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                "projectRelations": [
                    {
                        "updatedAt": "2026-02-15T17:41:33.246Z",
                        "createdAt": "2026-02-15T17:41:33.246Z",
                        "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                        "projectId": "EONlUm0d92HHHVBN",
                        "user": {
                            "updatedAt": "2026-02-26T00:55:17.000Z",
                            "createdAt": "2026-02-25T01:40:25.011Z",
                            "id": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                            "email": "pochtmanrca@gmail.com",
                            "firstName": "Roman",
                            "lastName": "Pochtman",
                            "personalizationAnswers": null,
                            "settings": {
                                "firstSuccessfulWorkflowId": "CoWsngJ0UMOjyzFL",
                                "userActivated": true,
                                "userActivatedAt": 1772064788001
                            },
                            "disabled": false,
                            "mfaEnabled": false,
                            "lastActiveAt": "2026-02-25",
                            "isPending": false
                        }
                    }
                ]
            }
        }
    ],
    "tags": [],
    "activeVersion": {
        "updatedAt": "2026-02-25T23:10:56.247Z",
        "createdAt": "2026-02-25T23:10:56.247Z",
        "versionId": "917dbfb7-18e0-49c5-b6a5-1187789ccb25",
        "workflowId": "e3eZTcjR5Ir7Zwgw",
        "nodes": [
            {
                "parameters": {
                    "rule": {
                        "interval": [
                            {
                                "field": "hours",
                                "hoursInterval": 72
                            }
                        ]
                    }
                },
                "id": "schedule-trigger",
                "name": "Schedule (Every 3 Days)",
                "type": "n8n-nodes-base.scheduleTrigger",
                "typeVersion": 1.2,
                "position": [
                    0,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsGet(hostname, path, headers) {\n  return new Promise((resolve, reject) => {\n    const opts = { hostname, path, method: 'GET', headers: headers || {} };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.end();\n  });\n}\n\nconst supabaseHost = $env.SUPABASE_URL.replace('https://', '');\nconst serviceKey = $env.SUPABASE_SERVICE_KEY;\nconst authHeaders = { 'Authorization': 'Bearer ' + serviceKey, 'apikey': serviceKey };\n\nlet recentTitles = [];\ntry {\n  const postsRes = await httpsGet(supabaseHost, '/rest/v1/blog_posts?select=id&order=created_at.desc&limit=5', authHeaders);\n  if (postsRes.status === 200) {\n    const posts = JSON.parse(postsRes.body);\n    for (const post of posts) {\n      const tRes = await httpsGet(supabaseHost, '/rest/v1/blog_post_translations?post_id=eq.' + post.id + '&locale=eq.en&select=title&limit=1', authHeaders);\n      if (tRes.status === 200) {\n        const tData = JSON.parse(tRes.body);\n        if (tData[0] && tData[0].title) recentTitles.push(tData[0].title);\n      }\n    }\n  }\n} catch (e) {}\n\nconst categories = [\n  'VPN technology, protocols, and online privacy tools',\n  'Cybersecurity threats, data breaches, and malware news',\n  'Internet censorship, country-level restrictions, and access to information',\n  'AI and tech startup developments affecting digital privacy',\n  'New privacy-focused apps, services, browsers, and tools',\n  'Tech regulation, antitrust actions, and data protection laws',\n  'Open source security tools and developer privacy resources',\n  'Digital rights, government surveillance, and whistleblower news'\n];\n\nconst hoursSinceEpoch = Math.floor(Date.now() / (1000 * 60 * 60));\nconst categoryIndex = hoursSinceEpoch % categories.length;\nconst focusCategory = categories[categoryIndex];\n\nreturn [{ json: { recentTitles, focusCategory, categoryIndex } }];"
                },
                "id": "fetch-recent",
                "name": "Fetch Recent Posts",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    250,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(60000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst recentTitles = $json.recentTitles || [];\nconst focusCategory = $json.focusCategory;\nconst perplexityKey = $env.PERPLEXITY_API_KEY;\n\nconst exclusionText = recentTitles.length > 0\n  ? '\\n\\nIMPORTANT \\u2014 DO NOT write about these topics, they were already covered recently:\\n' + recentTitles.map((t, i) => (i+1) + '. ' + t).join('\\n') + '\\n\\nPick a COMPLETELY DIFFERENT topic from any of the above.'\n  : '';\n\nconst systemContent = 'You are a senior tech journalist writing for Doppler VPN blog. Your audience is tech-savvy users who care about online privacy, security, and digital freedom.\\n\\nToday focus area: ' + focusCategory + '\\n\\nBROAD TOPIC SCOPE \\u2014 you may write about ANY of these areas:\\n- VPN technology, protocols, and online privacy\\n- Cybersecurity news, data breaches, and emerging threats\\n- Internet censorship and country-level access restrictions\\n- AI developments that affect privacy and security\\n- New privacy-focused apps, tools, browsers, and services\\n- Tech regulation, antitrust, and data protection laws (GDPR, etc.)\\n- Open source security tools and developer resources\\n- Digital rights, surveillance, and whistleblower stories\\n- Encrypted messaging and secure communication\\n- Cloud security and enterprise privacy' + exclusionText + '\\n\\nRequirements:\\n- Find a TRENDING, RECENT topic from the last 7 days (not evergreen content)\\n- Write 800-1200 words, SEO-optimized\\n- Use markdown headers (## and ###) and paragraphs\\n- Include practical advice for readers\\n- Start with a compelling H1 title on the first line (# Title)\\n- Be factual and cite your sources';\n\nconst userContent = 'Write a comprehensive blog post about a trending topic in: ' + focusCategory + '. Focus on the most newsworthy development from the past week. Include recent events, expert analysis, and actionable advice for readers.';\n\nconst res = await httpsPost('api.perplexity.ai', '/chat/completions', {\n  'Authorization': 'Bearer ' + perplexityKey\n}, {\n  model: 'sonar',\n  messages: [\n    { role: 'system', content: systemContent },\n    { role: 'user', content: userContent }\n  ],\n  max_tokens: 2000,\n  temperature: 0.7\n});\n\nif (res.status !== 200) {\n  throw new Error('Perplexity failed (' + res.status + '): ' + res.body.slice(0, 300));\n}\n\nconst data = JSON.parse(res.body);\nreturn [{ json: data }];"
                },
                "id": "perplexity-research",
                "name": "Perplexity Research",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    500,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const urlMod = require('url');\n\nconst response = $input.first().json;\nconst content = response.choices?.[0]?.message?.content || '';\nconst citations = response.citations || [];\n\nlet title = '';\nlet body = content;\n\nconst titleMatch = content.match(/^#\\s+(.+)$/m);\nif (titleMatch) {\n  title = titleMatch[1].trim();\n  body = content.replace(/^#\\s+.+$/m, '').trim();\n} else {\n  const lines = content.split('\\n').filter(l => l.trim());\n  title = lines[0] ? lines[0].replace(/^[#*]+\\s*/, '').trim() : 'Tech Security Update';\n  body = lines.slice(1).join('\\n').trim();\n}\n\nconst slug = title\n  .toLowerCase()\n  .replace(/[^a-z0-9\\s-]/g, '')\n  .replace(/\\s+/g, '-')\n  .replace(/-+/g, '-')\n  .slice(0, 80);\n\nconst plainBody = body.replace(/[#*_~`>\\[\\]()]/g, '').trim();\nconst excerpt = plainBody.slice(0, 200).trim() + '...';\nconst meta_description = plainBody.slice(0, 160).trim();\n\nconst source_links = citations.map(citUrl => {\n  try {\n    const parsed = urlMod.parse(citUrl);\n    const hostname = (parsed.hostname || '').replace('www.', '');\n    return { text: hostname, url: citUrl };\n  } catch (e) { return { text: citUrl, url: citUrl }; }\n}).filter(s => s.url);\n\nconst lowerTitle = title.toLowerCase();\nconst combined = lowerTitle + ' ' + body.toLowerCase().slice(0, 2000);\n\nconst tagRules = [\n  { tag: 'vpn', keywords: ['vpn', 'wireguard', 'openvpn', 'tunnel', 'proxy'] },\n  { tag: 'privacy', keywords: ['privacy', 'private', 'tracking', 'surveillance', 'gdpr', 'data protection'] },\n  { tag: 'cybersecurity', keywords: ['cyber', 'hack', 'breach', 'malware', 'ransomware', 'phishing', 'vulnerability'] },\n  { tag: 'ai', keywords: ['artificial intelligence', ' ai ', 'machine learning', 'deepfake', 'chatgpt', 'llm'] },\n  { tag: 'censorship', keywords: ['censor', 'blocked', 'restriction', 'firewall', 'banned', 'internet freedom'] },\n  { tag: 'regulation', keywords: ['regulation', 'law', 'legislation', 'antitrust', 'gdpr', 'compliance'] },\n  { tag: 'encryption', keywords: ['encrypt', 'end-to-end', 'e2ee', 'cryptograph', 'ssl', 'tls'] },\n  { tag: 'data-breach', keywords: ['breach', 'leaked', 'exposed', 'compromised', 'stolen data'] },\n  { tag: 'open-source', keywords: ['open source', 'open-source', 'github', 'foss'] },\n  { tag: 'apps', keywords: ['app ', 'browser', 'extension', 'tool', 'software'] }\n];\n\nconst tags = tagRules.filter(r => r.keywords.some(kw => combined.includes(kw))).map(r => r.tag).slice(0, 5);\nif (tags.length === 0) tags.push('tech-news');\n\nreturn [{ json: { title, slug: slug + '-' + Date.now().toString(36), content: body, excerpt, meta_description, source_links, tags, auto_translate: false, author: 'Doppler VPN' } }];"
                },
                "id": "format-content",
                "name": "Format Blog Content",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    750,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(30000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst apiKey = $env.BLOG_API_KEY;\nconst d = $json;\n\nconst res = await httpsPost('www.dopplervpn.org', '/api/blog/create', {\n  'Authorization': apiKey\n}, {\n  title: d.title,\n  content: d.content,\n  slug: d.slug,\n  excerpt: d.excerpt,\n  meta_description: d.meta_description,\n  source_links: d.source_links,\n  tags: d.tags,\n  auto_translate: false,\n  author: d.author\n});\n\nif (res.status !== 200 && res.status !== 201) {\n  throw new Error('Blog create failed (' + res.status + '): ' + res.body.slice(0, 500));\n}\n\nconst result = JSON.parse(res.body);\nreturn [{ json: { slug: result.slug || d.slug, blog_id: result.blog_id, ...result } }];"
                },
                "id": "create-blog",
                "name": "Create Blog Post",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1000,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const http = require('http');\n\nfunction httpPost(hostname, port, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, port, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = http.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(120000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst slug = $json.slug || $('Format Blog Content').first().json.slug;\nconst title = $('Format Blog Content').first().json.title;\nconst content = $('Format Blog Content').first().json.content;\nconst tags = $('Format Blog Content').first().json.tags;\n\nconst res = await httpPost('127.0.0.1', 5678, '/webhook/find-image', {}, { slug, title, content, tags });\n\nlet result = { success: false };\ntry { result = JSON.parse(res.body); } catch (e) {}\nreturn [{ json: { ...result, slug } }];"
                },
                "id": "find-image",
                "name": "Find Image",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1250,
                    0
                ],
                "continueOnFail": true
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(600000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst slug = $('Create Blog Post').first().json.slug || $('Format Blog Content').first().json.slug;\n\nif (!slug || typeof slug !== 'string' || slug.trim() === '') {\n  throw new Error('No valid slug found from Create Blog Post or Format Blog Content nodes');\n}\n\nconst apiKey = $env.BLOG_API_KEY;\nif (!apiKey) {\n  throw new Error('BLOG_API_KEY environment variable is not set');\n}\n\n// Call the translate API which handles all languages (parallelized server-side)\nconst res = await httpsPost('www.dopplervpn.org', '/api/blog/translate', {\n  'Authorization': apiKey\n}, { slug });\n\nif (res.status !== 200 && res.status !== 201) {\n  throw new Error('Translate failed (' + res.status + '): ' + res.body.slice(0, 500));\n}\n\nconst result = JSON.parse(res.body);\nreturn [{ json: { slug, translated: result.translated || [], total_translated: (result.translated || []).length, errors: result.errors || [] } }];"
                },
                "id": "translate-all",
                "name": "Translate All Languages",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1500,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const http = require('http');\n\nfunction httpPost(hostname, port, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, port, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = http.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.setTimeout(30000, () => { req.destroy(new Error('timeout')); });\n    req.write(data);\n    req.end();\n  });\n}\n\nconst slug = $('Create Blog Post').first().json.slug || $('Format Blog Content').first().json.slug;\n\nconst res = await httpPost('127.0.0.1', 5678, '/webhook/post-to-channels', {}, { slug });\n\nlet result = { success: false };\ntry { result = JSON.parse(res.body); } catch (e) {}\nreturn [{ json: result }];"
                },
                "id": "post-channels",
                "name": "Post to Channels",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1750,
                    0
                ],
                "continueOnFail": true
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\nconst botToken = $env.TELEGRAM_BOT_TOKEN;\nconst slug = $('Create Blog Post').first().json.slug || $('Format Blog Content').first().json.slug;\nconst title = $('Format Blog Content').first().json.title;\nconst imageSuccess = $('Find Image').first().json.success;\nconst totalTranslated = $('Translate All Languages').first().json.total_translated || 0;\nconst channelSuccess = $('Post to Channels').first().json.success;\n\nconst text = '\\ud83d\\udcdd Blog post pipeline complete!\\n\\n\\ud83d\\udcf0 ' + title + '\\n\\ud83d\\uddbc Image: ' + (imageSuccess ? '\\u2705 Generated' : '\\u274c Failed') + '\\n\\ud83c\\udf10 Translations: ' + totalTranslated + '\\n\\ud83d\\udce2 Channels: ' + (channelSuccess ? '\\u2705 Posted' : '\\u26a0\\ufe0f Check manually') + '\\n\\n\\ud83d\\udd17 https://www.dopplervpn.org/en/blog/' + slug + '\\n\\n\\u270f\\ufe0f Edit: https://www.dopplervpn.org/admin-dvpn';\n\nawait httpsPost('api.telegram.org', '/bot' + botToken + '/sendMessage', {}, {\n  chat_id: 218545546,\n  text: text,\n  parse_mode: 'HTML'\n});\n\nreturn [{ json: { notified: true, slug } }];"
                },
                "id": "notify-admin",
                "name": "Notify Roman",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    2000,
                    0
                ]
            }
        ],
        "connections": {
            "Schedule (Every 3 Days)": {
                "main": [
                    [
                        {
                            "node": "Fetch Recent Posts",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Fetch Recent Posts": {
                "main": [
                    [
                        {
                            "node": "Perplexity Research",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Perplexity Research": {
                "main": [
                    [
                        {
                            "node": "Format Blog Content",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Format Blog Content": {
                "main": [
                    [
                        {
                            "node": "Create Blog Post",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Create Blog Post": {
                "main": [
                    [
                        {
                            "node": "Find Image",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Find Image": {
                "main": [
                    [
                        {
                            "node": "Translate All Languages",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Translate All Languages": {
                "main": [
                    [
                        {
                            "node": "Post to Channels",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Post to Channels": {
                "main": [
                    [
                        {
                            "node": "Notify Roman",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            }
        },
        "authors": "Roman Pochtman",
        "name": null,
        "description": null,
        "autosaved": false,
        "workflowPublishHistory": [
            {
                "createdAt": "2026-02-25T23:10:56.299Z",
                "id": 90,
                "workflowId": "e3eZTcjR5Ir7Zwgw",
                "versionId": "917dbfb7-18e0-49c5-b6a5-1187789ccb25",
                "event": "activated",
                "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039"
            }
        ]
    }
}
