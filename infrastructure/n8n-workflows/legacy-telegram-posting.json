{
    "updatedAt": "2026-02-23T03:57:04.720Z",
    "createdAt": "2026-02-21T19:15:20.489Z",
    "id": "aXVg56pzAPWTw7VG",
    "name": "Doppler Telegram Channel Posting",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
        {
            "parameters": {
                "httpMethod": "POST",
                "path": "post-to-channels",
                "responseMode": "responseNode",
                "options": {}
            },
            "id": "webhook-trigger",
            "name": "Webhook (Post Trigger)",
            "type": "n8n-nodes-base.webhook",
            "typeVersion": 2,
            "position": [
                0,
                0
            ],
            "webhookId": "post-to-channels"
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsGet(hostname, path, headers) {\n  return new Promise((resolve, reject) => {\n    const opts = { hostname, path, method: 'GET', headers: headers || {} };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.end();\n  });\n}\n\nconst supabaseHost = $env.SUPABASE_URL.replace('https://', '');\nconst serviceKey = $env.SUPABASE_SERVICE_KEY;\nconst slug = ($input.first().json.body || $input.first().json).slug;\n\nif (!slug) {\n  return [{ json: { error: 'No slug provided' } }];\n}\n\nconst res = await httpsGet(supabaseHost,\n  '/rest/v1/blog_posts?slug=eq.' + slug + '&select=id,slug,image_url,blog_post_translations(locale,title,excerpt),blog_post_tags(blog_tags(slug))',\n  { 'Authorization': 'Bearer ' + serviceKey, 'apikey': serviceKey }\n);\n\nconst data = JSON.parse(res.body);\nconst post = Array.isArray(data) ? data[0] : data;\n\nif (!post || !post.slug) {\n  return [{ json: { error: 'Post not found' } }];\n}\n\nreturn [{ json: post }];"
            },
            "id": "fetch-post",
            "name": "Fetch Post from Supabase",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                250,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const post = $input.first().json;\n\nif (!post || !post.slug) {\n  return [{ json: { error: 'Post not found' } }];\n}\n\nconst translations = post.blog_post_translations || [];\nconst ruTrans = translations.find(t => t.locale === 'ru');\nconst enTrans = translations.find(t => t.locale === 'en');\n\nconst tagSlugs = (post.blog_post_tags || []).map(pt => pt.blog_tags ? pt.blog_tags.slug : null).filter(Boolean);\nconst hashtags = tagSlugs.length > 0\n  ? tagSlugs.map(t => '#' + t.replace(/-/g, '_')).join(' ')\n  : '#vpn #privacy #cybersecurity';\n\nfunction escapeHtml(s) {\n  return (s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n\nfunction formatPost(title, excerpt, slug, locale) {\n  const baseUrl = 'https://www.dopplervpn.org';\n  const url = baseUrl + '/' + locale + '/blog/' + slug;\n  return '<b>' + escapeHtml(title) + '</b>\\n\\n' + escapeHtml((excerpt || '').slice(0, 300)) + '\\n\\n\\ud83d\\udd17 <a href=\"' + url + '\">Read more</a>\\n\\n' + hashtags;\n}\n\nreturn [{ json: {\n  slug: post.slug,\n  image_url: post.image_url || null,\n  ru_text: ruTrans ? formatPost(ruTrans.title, ruTrans.excerpt, post.slug, 'ru') : null,\n  en_text: enTrans ? formatPost(enTrans.title, enTrans.excerpt, post.slug, 'en') : null\n}}];"
            },
            "id": "format-posts",
            "name": "Format Channel Posts",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                500,
                0
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "options": {
                        "caseSensitive": true,
                        "leftValue": "",
                        "typeValidation": "strict"
                    },
                    "conditions": [
                        {
                            "leftValue": "={{ $json.ru_text }}",
                            "rightValue": "",
                            "operator": {
                                "type": "string",
                                "operation": "isNotEmpty"
                            }
                        }
                    ],
                    "combinator": "and"
                }
            },
            "id": "if-ru",
            "name": "If RU Translation",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                750,
                -100
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "options": {
                        "caseSensitive": true,
                        "leftValue": "",
                        "typeValidation": "strict"
                    },
                    "conditions": [
                        {
                            "leftValue": "={{ $json.en_text }}",
                            "rightValue": "",
                            "operator": {
                                "type": "string",
                                "operation": "isNotEmpty"
                            }
                        }
                    ],
                    "combinator": "and"
                }
            },
            "id": "if-en",
            "name": "If EN Translation",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                750,
                100
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\nconst botToken = $env.TELEGRAM_BOT_TOKEN;\nconst chatId = '-1003525284412';\nconst imageUrl = $json.image_url;\nconst text = $json.ru_text;\n\nconst endpoint = imageUrl ? 'sendPhoto' : 'sendMessage';\nconst body = imageUrl\n  ? { chat_id: chatId, photo: imageUrl, caption: text, parse_mode: 'HTML' }\n  : { chat_id: chatId, text: text, parse_mode: 'HTML' };\n\nconst res = await httpsPost('api.telegram.org', '/bot' + botToken + '/' + endpoint, {}, body);\n\nconst result = JSON.parse(res.body);\nreturn [{ json: { posted_ru: result.ok || false } }];"
            },
            "id": "post-ru",
            "name": "Post to @dopplervpn (RU)",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1000,
                -100
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\nconst botToken = $env.TELEGRAM_BOT_TOKEN;\nconst chatId = '-1003716855563';\nconst imageUrl = $('Format Channel Posts').first().json.image_url;\nconst text = $('Format Channel Posts').first().json.en_text;\n\nconst endpoint = imageUrl ? 'sendPhoto' : 'sendMessage';\nconst body = imageUrl\n  ? { chat_id: chatId, photo: imageUrl, caption: text, parse_mode: 'HTML' }\n  : { chat_id: chatId, text: text, parse_mode: 'HTML' };\n\nconst res = await httpsPost('api.telegram.org', '/bot' + botToken + '/' + endpoint, {}, body);\n\nconst result = JSON.parse(res.body);\nreturn [{ json: { posted_en: result.ok || false } }];"
            },
            "id": "post-en",
            "name": "Post to @dopplervpnen (EN)",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1000,
                100
            ]
        },
        {
            "parameters": {
                "respondWith": "json",
                "responseBody": "={{ JSON.stringify({ success: true, slug: $('Format Channel Posts').first().json.slug }) }}"
            },
            "id": "respond",
            "name": "Respond Success",
            "type": "n8n-nodes-base.respondToWebhook",
            "typeVersion": 1.1,
            "position": [
                1250,
                0
            ]
        }
    ],
    "connections": {
        "Webhook (Post Trigger)": {
            "main": [
                [
                    {
                        "node": "Fetch Post from Supabase",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Fetch Post from Supabase": {
            "main": [
                [
                    {
                        "node": "Format Channel Posts",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Format Channel Posts": {
            "main": [
                [
                    {
                        "node": "If RU Translation",
                        "type": "main",
                        "index": 0
                    },
                    {
                        "node": "If EN Translation",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "If RU Translation": {
            "main": [
                [
                    {
                        "node": "Post to @dopplervpn (RU)",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Respond Success",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "If EN Translation": {
            "main": [
                [
                    {
                        "node": "Post to @dopplervpnen (EN)",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Respond Success",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Post to @dopplervpn (RU)": {
            "main": [
                [
                    {
                        "node": "Respond Success",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Post to @dopplervpnen (EN)": {
            "main": [
                [
                    {
                        "node": "Respond Success",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1",
        "callerPolicy": "workflowsFromSameOwner",
        "availableInMCP": false
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "7c92cb89-0cec-48da-98d7-9c2cb7d6e66b",
    "activeVersionId": "7c92cb89-0cec-48da-98d7-9c2cb7d6e66b",
    "versionCounter": 48,
    "triggerCount": 1,
    "shared": [
        {
            "updatedAt": "2026-02-21T19:15:20.491Z",
            "createdAt": "2026-02-21T19:15:20.491Z",
            "role": "workflow:owner",
            "workflowId": "aXVg56pzAPWTw7VG",
            "projectId": "EONlUm0d92HHHVBN",
            "project": {
                "updatedAt": "2026-02-25T02:05:40.807Z",
                "createdAt": "2026-02-15T17:41:33.246Z",
                "id": "EONlUm0d92HHHVBN",
                "name": "Roman Pochtman <pochtmanrca@gmail.com>",
                "type": "personal",
                "icon": null,
                "description": null,
                "creatorId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                "projectRelations": [
                    {
                        "updatedAt": "2026-02-15T17:41:33.246Z",
                        "createdAt": "2026-02-15T17:41:33.246Z",
                        "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                        "projectId": "EONlUm0d92HHHVBN",
                        "user": {
                            "updatedAt": "2026-02-26T00:55:17.000Z",
                            "createdAt": "2026-02-25T01:40:25.011Z",
                            "id": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                            "email": "pochtmanrca@gmail.com",
                            "firstName": "Roman",
                            "lastName": "Pochtman",
                            "personalizationAnswers": null,
                            "settings": {
                                "firstSuccessfulWorkflowId": "CoWsngJ0UMOjyzFL",
                                "userActivated": true,
                                "userActivatedAt": 1772064788001
                            },
                            "disabled": false,
                            "mfaEnabled": false,
                            "lastActiveAt": "2026-02-25",
                            "isPending": false
                        }
                    }
                ]
            }
        }
    ],
    "tags": [],
    "activeVersion": {
        "updatedAt": "2026-02-23T03:57:04.721Z",
        "createdAt": "2026-02-23T03:57:04.721Z",
        "versionId": "7c92cb89-0cec-48da-98d7-9c2cb7d6e66b",
        "workflowId": "aXVg56pzAPWTw7VG",
        "nodes": [
            {
                "parameters": {
                    "httpMethod": "POST",
                    "path": "post-to-channels",
                    "responseMode": "responseNode",
                    "options": {}
                },
                "id": "webhook-trigger",
                "name": "Webhook (Post Trigger)",
                "type": "n8n-nodes-base.webhook",
                "typeVersion": 2,
                "position": [
                    0,
                    0
                ],
                "webhookId": "post-to-channels"
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsGet(hostname, path, headers) {\n  return new Promise((resolve, reject) => {\n    const opts = { hostname, path, method: 'GET', headers: headers || {} };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.end();\n  });\n}\n\nconst supabaseHost = $env.SUPABASE_URL.replace('https://', '');\nconst serviceKey = $env.SUPABASE_SERVICE_KEY;\nconst slug = ($input.first().json.body || $input.first().json).slug;\n\nif (!slug) {\n  return [{ json: { error: 'No slug provided' } }];\n}\n\nconst res = await httpsGet(supabaseHost,\n  '/rest/v1/blog_posts?slug=eq.' + slug + '&select=id,slug,image_url,blog_post_translations(locale,title,excerpt),blog_post_tags(blog_tags(slug))',\n  { 'Authorization': 'Bearer ' + serviceKey, 'apikey': serviceKey }\n);\n\nconst data = JSON.parse(res.body);\nconst post = Array.isArray(data) ? data[0] : data;\n\nif (!post || !post.slug) {\n  return [{ json: { error: 'Post not found' } }];\n}\n\nreturn [{ json: post }];"
                },
                "id": "fetch-post",
                "name": "Fetch Post from Supabase",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    250,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const post = $input.first().json;\n\nif (!post || !post.slug) {\n  return [{ json: { error: 'Post not found' } }];\n}\n\nconst translations = post.blog_post_translations || [];\nconst ruTrans = translations.find(t => t.locale === 'ru');\nconst enTrans = translations.find(t => t.locale === 'en');\n\nconst tagSlugs = (post.blog_post_tags || []).map(pt => pt.blog_tags ? pt.blog_tags.slug : null).filter(Boolean);\nconst hashtags = tagSlugs.length > 0\n  ? tagSlugs.map(t => '#' + t.replace(/-/g, '_')).join(' ')\n  : '#vpn #privacy #cybersecurity';\n\nfunction escapeHtml(s) {\n  return (s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n}\n\nfunction formatPost(title, excerpt, slug, locale) {\n  const baseUrl = 'https://www.dopplervpn.org';\n  const url = baseUrl + '/' + locale + '/blog/' + slug;\n  return '<b>' + escapeHtml(title) + '</b>\\n\\n' + escapeHtml((excerpt || '').slice(0, 300)) + '\\n\\n\\ud83d\\udd17 <a href=\"' + url + '\">Read more</a>\\n\\n' + hashtags;\n}\n\nreturn [{ json: {\n  slug: post.slug,\n  image_url: post.image_url || null,\n  ru_text: ruTrans ? formatPost(ruTrans.title, ruTrans.excerpt, post.slug, 'ru') : null,\n  en_text: enTrans ? formatPost(enTrans.title, enTrans.excerpt, post.slug, 'en') : null\n}}];"
                },
                "id": "format-posts",
                "name": "Format Channel Posts",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    500,
                    0
                ]
            },
            {
                "parameters": {
                    "conditions": {
                        "options": {
                            "caseSensitive": true,
                            "leftValue": "",
                            "typeValidation": "strict"
                        },
                        "conditions": [
                            {
                                "leftValue": "={{ $json.ru_text }}",
                                "rightValue": "",
                                "operator": {
                                    "type": "string",
                                    "operation": "isNotEmpty"
                                }
                            }
                        ],
                        "combinator": "and"
                    }
                },
                "id": "if-ru",
                "name": "If RU Translation",
                "type": "n8n-nodes-base.if",
                "typeVersion": 2,
                "position": [
                    750,
                    -100
                ]
            },
            {
                "parameters": {
                    "conditions": {
                        "options": {
                            "caseSensitive": true,
                            "leftValue": "",
                            "typeValidation": "strict"
                        },
                        "conditions": [
                            {
                                "leftValue": "={{ $json.en_text }}",
                                "rightValue": "",
                                "operator": {
                                    "type": "string",
                                    "operation": "isNotEmpty"
                                }
                            }
                        ],
                        "combinator": "and"
                    }
                },
                "id": "if-en",
                "name": "If EN Translation",
                "type": "n8n-nodes-base.if",
                "typeVersion": 2,
                "position": [
                    750,
                    100
                ]
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\nconst botToken = $env.TELEGRAM_BOT_TOKEN;\nconst chatId = '-1003525284412';\nconst imageUrl = $json.image_url;\nconst text = $json.ru_text;\n\nconst endpoint = imageUrl ? 'sendPhoto' : 'sendMessage';\nconst body = imageUrl\n  ? { chat_id: chatId, photo: imageUrl, caption: text, parse_mode: 'HTML' }\n  : { chat_id: chatId, text: text, parse_mode: 'HTML' };\n\nconst res = await httpsPost('api.telegram.org', '/bot' + botToken + '/' + endpoint, {}, body);\n\nconst result = JSON.parse(res.body);\nreturn [{ json: { posted_ru: result.ok || false } }];"
                },
                "id": "post-ru",
                "name": "Post to @dopplervpn (RU)",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1000,
                    -100
                ]
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\n\nfunction httpsPost(hostname, path, headers, body) {\n  return new Promise((resolve, reject) => {\n    const data = JSON.stringify(body);\n    const opts = {\n      hostname, path, method: 'POST',\n      headers: { ...headers, 'Content-Type': 'application/json', 'Content-Length': Buffer.byteLength(data) }\n    };\n    const req = https.request(opts, (res) => {\n      const chunks = [];\n      res.on('data', (c) => chunks.push(c));\n      res.on('end', () => resolve({ status: res.statusCode, body: Buffer.concat(chunks).toString() }));\n    });\n    req.on('error', reject);\n    req.write(data);\n    req.end();\n  });\n}\n\nconst botToken = $env.TELEGRAM_BOT_TOKEN;\nconst chatId = '-1003716855563';\nconst imageUrl = $('Format Channel Posts').first().json.image_url;\nconst text = $('Format Channel Posts').first().json.en_text;\n\nconst endpoint = imageUrl ? 'sendPhoto' : 'sendMessage';\nconst body = imageUrl\n  ? { chat_id: chatId, photo: imageUrl, caption: text, parse_mode: 'HTML' }\n  : { chat_id: chatId, text: text, parse_mode: 'HTML' };\n\nconst res = await httpsPost('api.telegram.org', '/bot' + botToken + '/' + endpoint, {}, body);\n\nconst result = JSON.parse(res.body);\nreturn [{ json: { posted_en: result.ok || false } }];"
                },
                "id": "post-en",
                "name": "Post to @dopplervpnen (EN)",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1000,
                    100
                ]
            },
            {
                "parameters": {
                    "respondWith": "json",
                    "responseBody": "={{ JSON.stringify({ success: true, slug: $('Format Channel Posts').first().json.slug }) }}"
                },
                "id": "respond",
                "name": "Respond Success",
                "type": "n8n-nodes-base.respondToWebhook",
                "typeVersion": 1.1,
                "position": [
                    1250,
                    0
                ]
            }
        ],
        "connections": {
            "Webhook (Post Trigger)": {
                "main": [
                    [
                        {
                            "node": "Fetch Post from Supabase",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Fetch Post from Supabase": {
                "main": [
                    [
                        {
                            "node": "Format Channel Posts",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Format Channel Posts": {
                "main": [
                    [
                        {
                            "node": "If RU Translation",
                            "type": "main",
                            "index": 0
                        },
                        {
                            "node": "If EN Translation",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "If RU Translation": {
                "main": [
                    [
                        {
                            "node": "Post to @dopplervpn (RU)",
                            "type": "main",
                            "index": 0
                        }
                    ],
                    [
                        {
                            "node": "Respond Success",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "If EN Translation": {
                "main": [
                    [
                        {
                            "node": "Post to @dopplervpnen (EN)",
                            "type": "main",
                            "index": 0
                        }
                    ],
                    [
                        {
                            "node": "Respond Success",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Post to @dopplervpn (RU)": {
                "main": [
                    [
                        {
                            "node": "Respond Success",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Post to @dopplervpnen (EN)": {
                "main": [
                    [
                        {
                            "node": "Respond Success",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            }
        },
        "authors": "Roman Pochtman",
        "name": null,
        "description": null,
        "autosaved": false,
        "workflowPublishHistory": [
            {
                "createdAt": "2026-02-23T03:57:04.780Z",
                "id": 83,
                "workflowId": "aXVg56pzAPWTw7VG",
                "versionId": "7c92cb89-0cec-48da-98d7-9c2cb7d6e66b",
                "event": "activated",
                "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039"
            }
        ]
    }
}
