{
    "updatedAt": "2026-02-26T02:18:04.439Z",
    "createdAt": "2026-02-26T00:00:57.242Z",
    "id": "M6Gm4TKM6YwGzygG",
    "name": "Doppler Editorial \u2014 Topic Discovery",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
        {
            "parameters": {
                "rule": {
                    "interval": [
                        {
                            "triggerAtHour": 8
                        },
                        {
                            "triggerAtHour": 13
                        },
                        {
                            "triggerAtHour": 18
                        }
                    ]
                }
            },
            "id": "schedule-trigger",
            "name": "Schedule",
            "type": "n8n-nodes-base.scheduleTrigger",
            "typeVersion": 1.2,
            "position": [
                0,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const hour = new Date().getUTCHours();\nlet timeSlot = 'morning';\nif (hour >= 12 && hour < 16) timeSlot = 'midday';\nif (hour >= 16) timeSlot = 'afternoon';\n\nconst dayOfWeek = new Date().getUTCDay();\nconst isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n\nconst combos = {\n  morning: [\n    ['twitter', 'google-trends'],\n    ['twitter', 'hacker-news'],\n    ['google-trends', 'reddit'],\n  ],\n  midday: [\n    ['reddit', 'hacker-news'],\n    ['tech-rss', 'reddit'],\n    ['hacker-news', 'twitter'],\n  ],\n  afternoon: [\n    ['tech-rss', 'telegram-ru'],\n    ['twitter', 'tech-rss'],\n    ['reddit', 'telegram-ru'],\n  ],\n};\n\nconst slotCombos = combos[timeSlot];\nconst combo = slotCombos[dayOfWeek % slotCombos.length];\n\nlet templateType = 'quick-take';\nif (timeSlot === 'midday') {\n  templateType = dayOfWeek % 2 === 0 ? 'analysis' : 'meme';\n}\nif (timeSlot === 'afternoon') {\n  if (dayOfWeek === 5) templateType = 'roundup';\n  else templateType = dayOfWeek % 2 === 0 ? 'meme' : 'quick-take';\n}\nif (isWeekend) {\n  templateType = dayOfWeek % 2 === 0 ? 'meme' : 'roundup';\n}\n\nreturn [{\n  json: {\n    timeSlot,\n    sources: combo,\n    sourcesStr: combo.join('+'),\n    templateType,\n    dayOfWeek,\n    isWeekend,\n  }\n}];"
            },
            "id": "source-rotation",
            "name": "Source Rotation",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                250,
                0
            ]
        },
        {
            "parameters": {
                "method": "POST",
                "url": "https://api.perplexity.ai/chat/completions",
                "sendHeaders": true,
                "headerParameters": {
                    "parameters": [
                        {
                            "name": "Authorization",
                            "value": "=Bearer {{ $env.PERPLEXITY_API_KEY }}"
                        },
                        {
                            "name": "Content-Type",
                            "value": "application/json"
                        }
                    ]
                },
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={\n  \"model\": \"sonar\",\n  \"search_recency_filter\": \"day\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a tech news researcher. Find the single most newsworthy event from TODAY ONLY ({{ new Date().toISOString().split('T')[0] }}) using these sources: {{ $json.sourcesStr }}.\\n\\nTOPIC AREAS: VPN/privacy, AI launches, tech regulation, censorship, cybersecurity, big tech, startups.\\n\\nCRITICAL \u2014 ONLY REAL EVENTS:\\n- The event must have been ANNOUNCED, LAUNCHED, SIGNED, LEAKED, PASSED, or HAPPENED today.\\n- Do NOT return predictions, forecasts, analyses, or opinion pieces.\\n- Do NOT return stories about something that is 'expected to', 'poised to', 'planning to', or 'considering'.\\n- If nothing concrete happened today, return {\\\"topic\\\": \\\"\\\", \\\"headline\\\": \\\"\\\", \\\"summary\\\": \\\"\\\", \\\"key_quotes\\\": [], \\\"topic_category\\\": \\\"\\\", \\\"sources\\\": []}.\\n\\nSOURCE QUALITY:\\n- Return 2-3 direct URLs to specific articles about THIS event (not homepages, not archive pages, not category pages).\\n- Each URL must point to an individual article with a real path (e.g., /2026/02/article-slug, not just /news/).\\n- If you cannot find specific article URLs, return an empty sources array.\\n\\nQUOTE RULES:\\n- key_quotes: ONLY include real quotes with real person names or verified handles.\\n- If no real attributed quotes exist, return an empty key_quotes array.\\n- NEVER fabricate quotes or handles.\\n\\nReturn ONLY valid JSON: {\\\"topic\\\": \\\"string\\\", \\\"headline\\\": \\\"max 70 chars\\\", \\\"summary\\\": \\\"200 words max factual summary of what happened\\\", \\\"key_quotes\\\": [{\\\"text\\\": \\\"...\\\", \\\"author\\\": \\\"Real Name or @handle\\\", \\\"source\\\": \\\"outlet\\\"}], \\\"topic_category\\\": \\\"one of: vpn-privacy, ai-launches, ai-regulation, big-tech, us-policy, censorship, cybersecurity, streaming, startup-vc\\\", \\\"sources\\\": [\\\"url1\\\", \\\"url2\\\"]}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"Find the most important tech event that ACTUALLY HAPPENED today {{ new Date().toISOString().split('T')[0] }}. Template: {{ $json.templateType }}. If meme/roundup, focus on viral moments. Must be a real concrete event \u2014 not a prediction or forecast.\"\n    }\n  ]\n}",
                "options": {
                    "timeout": 30000,
                    "response": {
                        "response": {
                            "responseFormat": "json"
                        }
                    }
                }
            },
            "id": "perplexity-research",
            "name": "Perplexity Research",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                500,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const input = $input.first().json;\nconst prevData = $('Source Rotation').first().json;\n\nlet content = input.choices[0].message.content;\nif (content.startsWith('```')) {\n  content = content.replace(/^```(?:json)?\\n?/, '').replace(/\\n?```$/, '');\n}\nlet research;\ntry {\n  research = JSON.parse(content);\n} catch (e) {\n  const match = content.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    research = JSON.parse(match[0]);\n  } else {\n    throw new Error('Failed to parse: ' + content.substring(0, 200));\n  }\n}\n\n// Skip if Perplexity returned empty (no real event found)\nif (!research.topic || research.topic.trim() === '') {\n  return [{\n    json: {\n      topic: '',\n      headline: '',\n      summary: '',\n      key_quotes: [],\n      topicCategory: '',\n      sources: [],\n      sourceLinks: [],\n      templateType: prevData.templateType,\n      sourcesStr: prevData.sourcesStr,\n      timeSlot: prevData.timeSlot,\n      date: new Date().toISOString().split('T')[0],\n      isDuplicate: true, // Force skip\n    }\n  }];\n}\n\n// Extract topic keywords for relevance checking\nconst topicWords = (research.topic || '')\n  .toLowerCase()\n  .split(/[^a-z0-9]+/)\n  .filter(w => w.length > 3 && !['that', 'this', 'with', 'from', 'what', 'when', 'where', 'most', 'more', 'than', 'into', 'over', 'about', 'been', 'have', 'will', 'could', 'would', 'should'].includes(w));\n\n// Domains known to be irrelevant for tech news\nconst BAD_DOMAINS = ['pinterest.com', 'facebook.com', 'instagram.com', 'linkedin.com/feed', 'youtube.com/watch', 'tiktok.com', 'amazon.com/dp'];\n\nfunction isRelevantUrl(url) {\n  if (!url || !url.startsWith('http')) return false;\n  const lower = url.toLowerCase();\n  \n  // Block known bad domains\n  if (BAD_DOMAINS.some(d => lower.includes(d))) return false;\n  \n  // Filter out homepages, archives, generic pages\n  const path = lower.replace(/^https?:\\/\\/[^/]+/, '');\n  if (path.length < 15) return false; // Too short = homepage\n  if (/\\/archive|\\/tag\\/|\\/category\\/|\\/topics?\\/|\\/news\\/?$|\\/blog\\/?$|\\/search/i.test(path)) return false;\n  \n  // Check if any topic keyword appears in the URL\n  const matchCount = topicWords.filter(w => lower.includes(w)).length;\n  return matchCount >= 1;\n}\n\n// Perplexity citations + research JSON sources\nconst citations = (input.citations || []).filter(u => u && u.startsWith('http'));\nconst researchSources = (research.sources || []).filter(u => u && u.startsWith('http'));\nconst allUrls = [...citations, ...researchSources].filter((v, i, a) => a.indexOf(v) === i);\n\n// Filter for relevant sources\nlet relevantSources = allUrls.filter(isRelevantUrl).slice(0, 3);\n\n// Fallback: if no keyword-matched sources, take citations with real article paths\nif (relevantSources.length === 0 && citations.length > 0) {\n  relevantSources = citations.filter(u => {\n    const path = u.toLowerCase().replace(/^https?:\\/\\/[^/]+/, '');\n    return path.length > 20 && !BAD_DOMAINS.some(d => u.toLowerCase().includes(d));\n  }).slice(0, 3);\n}\n\nreturn [{\n  json: {\n    topic: research.topic || '',\n    headline: research.headline || '',\n    summary: research.summary || '',\n    key_quotes: (research.key_quotes || []).filter(q => q && q.text && q.author),\n    topicCategory: research.topic_category || '',\n    sources: relevantSources,\n    sourceLinks: relevantSources,\n    templateType: prevData.templateType,\n    sourcesStr: prevData.sourcesStr,\n    timeSlot: prevData.timeSlot,\n    date: new Date().toISOString().split('T')[0],\n  }\n}];"
            },
            "id": "parse-research",
            "name": "Parse Research",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                750,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const https = require('https');\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\n\nconst hostname = supabaseUrl.replace('https://', '');\nconst options = {\n  hostname,\n  path: '/rest/v1/blog_post_translations?locale=eq.en&select=title&order=created_at.desc&limit=10',\n  headers: {\n    'apikey': supabaseKey,\n    'Authorization': 'Bearer ' + supabaseKey,\n  }\n};\n\nconst data = await new Promise((resolve, reject) => {\n  const req = https.get(options, (res) => {\n    let body = '';\n    res.on('data', chunk => body += chunk);\n    res.on('end', () => resolve(JSON.parse(body)));\n  });\n  req.on('error', reject);\n});\n\nconst existingTitles = data.map(r => r.title.toLowerCase());\nconst proposedTopic = ($input.first().json.topic || '').toLowerCase();\n\nconst isDuplicate = existingTitles.some(t => {\n  const words = proposedTopic.split(' ').filter(w => w.length > 4);\n  if (words.length === 0) return false;\n  const matches = words.filter(w => t.includes(w));\n  return matches.length >= 3;\n});\n\nreturn [{\n  json: {\n    ...$input.first().json,\n    isDuplicate,\n    existingTitles,\n  }\n}];"
            },
            "id": "dedup-check",
            "name": "Dedup Check",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1000,
                0
            ]
        },
        {
            "parameters": {
                "conditions": {
                    "options": {
                        "caseSensitive": true,
                        "leftValue": "",
                        "typeValidation": "strict"
                    },
                    "conditions": [
                        {
                            "id": "dedup-condition",
                            "leftValue": "={{ $json.isDuplicate }}",
                            "rightValue": false,
                            "operator": {
                                "type": "boolean",
                                "operation": "equals",
                                "singleValue": true
                            }
                        }
                    ],
                    "combinator": "and"
                }
            },
            "id": "if-not-duplicate",
            "name": "Not Duplicate?",
            "type": "n8n-nodes-base.if",
            "typeVersion": 2,
            "position": [
                1250,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const input = $input.first().json;\nconst { existingTitles, isDuplicate, ...topicData } = input;\n\nreturn [{\n  json: {\n    ...topicData,\n    status: 'ready_for_generation',\n    discoveredAt: new Date().toISOString(),\n  }\n}];"
            },
            "id": "format-output",
            "name": "Format Output",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1500,
                0
            ]
        },
        {
            "parameters": {
                "jsCode": "const input = $input.first().json;\nreturn [{\n  json: {\n    status: 'skipped_duplicate',\n    topic: input.topic,\n    message: 'Topic was too similar to recent posts. Will try again next slot.',\n  }\n}];"
            },
            "id": "skip-duplicate",
            "name": "Skip (Duplicate)",
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                1500,
                300
            ]
        },
        {
            "id": "call-content-gen",
            "name": "Call Content Generation",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                1740,
                0
            ],
            "parameters": {
                "method": "POST",
                "url": "http://localhost:5678/webhook/doppler-content-gen",
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ JSON.stringify($json) }}",
                "options": {
                    "timeout": 300000
                }
            }
        },
        {
            "id": "call-image-pipeline",
            "name": "Call Image Pipeline",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                1980,
                0
            ],
            "parameters": {
                "method": "POST",
                "url": "http://localhost:5678/webhook/doppler-image-gen",
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ JSON.stringify($json) }}",
                "options": {
                    "timeout": 120000
                }
            }
        },
        {
            "id": "call-publish",
            "name": "Call Publish",
            "type": "n8n-nodes-base.httpRequest",
            "typeVersion": 4.2,
            "position": [
                2220,
                0
            ],
            "parameters": {
                "method": "POST",
                "url": "http://localhost:5678/webhook/doppler-publish",
                "sendBody": true,
                "specifyBody": "json",
                "jsonBody": "={{ JSON.stringify($json) }}",
                "options": {
                    "timeout": 360000
                }
            }
        }
    ],
    "connections": {
        "Schedule": {
            "main": [
                [
                    {
                        "node": "Source Rotation",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Source Rotation": {
            "main": [
                [
                    {
                        "node": "Perplexity Research",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Perplexity Research": {
            "main": [
                [
                    {
                        "node": "Parse Research",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Parse Research": {
            "main": [
                [
                    {
                        "node": "Dedup Check",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Dedup Check": {
            "main": [
                [
                    {
                        "node": "Not Duplicate?",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Not Duplicate?": {
            "main": [
                [
                    {
                        "node": "Format Output",
                        "type": "main",
                        "index": 0
                    }
                ],
                [
                    {
                        "node": "Skip (Duplicate)",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Format Output": {
            "main": [
                [
                    {
                        "node": "Call Content Generation",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Call Content Generation": {
            "main": [
                [
                    {
                        "node": "Call Image Pipeline",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Call Image Pipeline": {
            "main": [
                [
                    {
                        "node": "Call Publish",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "settings": {
        "executionOrder": "v1",
        "callerPolicy": "workflowsFromSameOwner",
        "availableInMCP": false
    },
    "staticData": {
        "node:Schedule": {
            "recurrenceRules": []
        }
    },
    "meta": null,
    "pinData": null,
    "versionId": "f2f6673a-8729-4982-861a-0cf88d797ebe",
    "activeVersionId": "f2f6673a-8729-4982-861a-0cf88d797ebe",
    "versionCounter": 29,
    "triggerCount": 1,
    "shared": [
        {
            "updatedAt": "2026-02-26T00:00:57.246Z",
            "createdAt": "2026-02-26T00:00:57.246Z",
            "role": "workflow:owner",
            "workflowId": "M6Gm4TKM6YwGzygG",
            "projectId": "EONlUm0d92HHHVBN",
            "project": {
                "updatedAt": "2026-02-25T02:05:40.807Z",
                "createdAt": "2026-02-15T17:41:33.246Z",
                "id": "EONlUm0d92HHHVBN",
                "name": "Roman Pochtman <pochtmanrca@gmail.com>",
                "type": "personal",
                "icon": null,
                "description": null,
                "creatorId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                "projectRelations": [
                    {
                        "updatedAt": "2026-02-15T17:41:33.246Z",
                        "createdAt": "2026-02-15T17:41:33.246Z",
                        "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                        "projectId": "EONlUm0d92HHHVBN",
                        "user": {
                            "updatedAt": "2026-02-26T00:55:17.000Z",
                            "createdAt": "2026-02-25T01:40:25.011Z",
                            "id": "00f12e0f-5634-430b-ab08-fd0aefa1a039",
                            "email": "pochtmanrca@gmail.com",
                            "firstName": "Roman",
                            "lastName": "Pochtman",
                            "personalizationAnswers": null,
                            "settings": {
                                "firstSuccessfulWorkflowId": "CoWsngJ0UMOjyzFL",
                                "userActivated": true,
                                "userActivatedAt": 1772064788001
                            },
                            "disabled": false,
                            "mfaEnabled": false,
                            "lastActiveAt": "2026-02-25",
                            "isPending": false
                        }
                    }
                ]
            }
        }
    ],
    "tags": [],
    "activeVersion": {
        "updatedAt": "2026-02-26T02:18:04.441Z",
        "createdAt": "2026-02-26T02:18:04.441Z",
        "versionId": "f2f6673a-8729-4982-861a-0cf88d797ebe",
        "workflowId": "M6Gm4TKM6YwGzygG",
        "nodes": [
            {
                "parameters": {
                    "rule": {
                        "interval": [
                            {
                                "triggerAtHour": 8
                            },
                            {
                                "triggerAtHour": 13
                            },
                            {
                                "triggerAtHour": 18
                            }
                        ]
                    }
                },
                "id": "schedule-trigger",
                "name": "Schedule",
                "type": "n8n-nodes-base.scheduleTrigger",
                "typeVersion": 1.2,
                "position": [
                    0,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const hour = new Date().getUTCHours();\nlet timeSlot = 'morning';\nif (hour >= 12 && hour < 16) timeSlot = 'midday';\nif (hour >= 16) timeSlot = 'afternoon';\n\nconst dayOfWeek = new Date().getUTCDay();\nconst isWeekend = dayOfWeek === 0 || dayOfWeek === 6;\n\nconst combos = {\n  morning: [\n    ['twitter', 'google-trends'],\n    ['twitter', 'hacker-news'],\n    ['google-trends', 'reddit'],\n  ],\n  midday: [\n    ['reddit', 'hacker-news'],\n    ['tech-rss', 'reddit'],\n    ['hacker-news', 'twitter'],\n  ],\n  afternoon: [\n    ['tech-rss', 'telegram-ru'],\n    ['twitter', 'tech-rss'],\n    ['reddit', 'telegram-ru'],\n  ],\n};\n\nconst slotCombos = combos[timeSlot];\nconst combo = slotCombos[dayOfWeek % slotCombos.length];\n\nlet templateType = 'quick-take';\nif (timeSlot === 'midday') {\n  templateType = dayOfWeek % 2 === 0 ? 'analysis' : 'meme';\n}\nif (timeSlot === 'afternoon') {\n  if (dayOfWeek === 5) templateType = 'roundup';\n  else templateType = dayOfWeek % 2 === 0 ? 'meme' : 'quick-take';\n}\nif (isWeekend) {\n  templateType = dayOfWeek % 2 === 0 ? 'meme' : 'roundup';\n}\n\nreturn [{\n  json: {\n    timeSlot,\n    sources: combo,\n    sourcesStr: combo.join('+'),\n    templateType,\n    dayOfWeek,\n    isWeekend,\n  }\n}];"
                },
                "id": "source-rotation",
                "name": "Source Rotation",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    250,
                    0
                ]
            },
            {
                "parameters": {
                    "method": "POST",
                    "url": "https://api.perplexity.ai/chat/completions",
                    "sendHeaders": true,
                    "headerParameters": {
                        "parameters": [
                            {
                                "name": "Authorization",
                                "value": "=Bearer {{ $env.PERPLEXITY_API_KEY }}"
                            },
                            {
                                "name": "Content-Type",
                                "value": "application/json"
                            }
                        ]
                    },
                    "sendBody": true,
                    "specifyBody": "json",
                    "jsonBody": "={\n  \"model\": \"sonar\",\n  \"search_recency_filter\": \"day\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a tech news researcher. Find the single most newsworthy event from TODAY ONLY ({{ new Date().toISOString().split('T')[0] }}) using these sources: {{ $json.sourcesStr }}.\\n\\nTOPIC AREAS: VPN/privacy, AI launches, tech regulation, censorship, cybersecurity, big tech, startups.\\n\\nCRITICAL \u2014 ONLY REAL EVENTS:\\n- The event must have been ANNOUNCED, LAUNCHED, SIGNED, LEAKED, PASSED, or HAPPENED today.\\n- Do NOT return predictions, forecasts, analyses, or opinion pieces.\\n- Do NOT return stories about something that is 'expected to', 'poised to', 'planning to', or 'considering'.\\n- If nothing concrete happened today, return {\\\"topic\\\": \\\"\\\", \\\"headline\\\": \\\"\\\", \\\"summary\\\": \\\"\\\", \\\"key_quotes\\\": [], \\\"topic_category\\\": \\\"\\\", \\\"sources\\\": []}.\\n\\nSOURCE QUALITY:\\n- Return 2-3 direct URLs to specific articles about THIS event (not homepages, not archive pages, not category pages).\\n- Each URL must point to an individual article with a real path (e.g., /2026/02/article-slug, not just /news/).\\n- If you cannot find specific article URLs, return an empty sources array.\\n\\nQUOTE RULES:\\n- key_quotes: ONLY include real quotes with real person names or verified handles.\\n- If no real attributed quotes exist, return an empty key_quotes array.\\n- NEVER fabricate quotes or handles.\\n\\nReturn ONLY valid JSON: {\\\"topic\\\": \\\"string\\\", \\\"headline\\\": \\\"max 70 chars\\\", \\\"summary\\\": \\\"200 words max factual summary of what happened\\\", \\\"key_quotes\\\": [{\\\"text\\\": \\\"...\\\", \\\"author\\\": \\\"Real Name or @handle\\\", \\\"source\\\": \\\"outlet\\\"}], \\\"topic_category\\\": \\\"one of: vpn-privacy, ai-launches, ai-regulation, big-tech, us-policy, censorship, cybersecurity, streaming, startup-vc\\\", \\\"sources\\\": [\\\"url1\\\", \\\"url2\\\"]}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"Find the most important tech event that ACTUALLY HAPPENED today {{ new Date().toISOString().split('T')[0] }}. Template: {{ $json.templateType }}. If meme/roundup, focus on viral moments. Must be a real concrete event \u2014 not a prediction or forecast.\"\n    }\n  ]\n}",
                    "options": {
                        "timeout": 30000,
                        "response": {
                            "response": {
                                "responseFormat": "json"
                            }
                        }
                    }
                },
                "id": "perplexity-research",
                "name": "Perplexity Research",
                "type": "n8n-nodes-base.httpRequest",
                "typeVersion": 4.2,
                "position": [
                    500,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const input = $input.first().json;\nconst prevData = $('Source Rotation').first().json;\n\nlet content = input.choices[0].message.content;\nif (content.startsWith('```')) {\n  content = content.replace(/^```(?:json)?\\n?/, '').replace(/\\n?```$/, '');\n}\nlet research;\ntry {\n  research = JSON.parse(content);\n} catch (e) {\n  const match = content.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    research = JSON.parse(match[0]);\n  } else {\n    throw new Error('Failed to parse: ' + content.substring(0, 200));\n  }\n}\n\n// Skip if Perplexity returned empty (no real event found)\nif (!research.topic || research.topic.trim() === '') {\n  return [{\n    json: {\n      topic: '',\n      headline: '',\n      summary: '',\n      key_quotes: [],\n      topicCategory: '',\n      sources: [],\n      sourceLinks: [],\n      templateType: prevData.templateType,\n      sourcesStr: prevData.sourcesStr,\n      timeSlot: prevData.timeSlot,\n      date: new Date().toISOString().split('T')[0],\n      isDuplicate: true, // Force skip\n    }\n  }];\n}\n\n// Extract topic keywords for relevance checking\nconst topicWords = (research.topic || '')\n  .toLowerCase()\n  .split(/[^a-z0-9]+/)\n  .filter(w => w.length > 3 && !['that', 'this', 'with', 'from', 'what', 'when', 'where', 'most', 'more', 'than', 'into', 'over', 'about', 'been', 'have', 'will', 'could', 'would', 'should'].includes(w));\n\n// Domains known to be irrelevant for tech news\nconst BAD_DOMAINS = ['pinterest.com', 'facebook.com', 'instagram.com', 'linkedin.com/feed', 'youtube.com/watch', 'tiktok.com', 'amazon.com/dp'];\n\nfunction isRelevantUrl(url) {\n  if (!url || !url.startsWith('http')) return false;\n  const lower = url.toLowerCase();\n  \n  // Block known bad domains\n  if (BAD_DOMAINS.some(d => lower.includes(d))) return false;\n  \n  // Filter out homepages, archives, generic pages\n  const path = lower.replace(/^https?:\\/\\/[^/]+/, '');\n  if (path.length < 15) return false; // Too short = homepage\n  if (/\\/archive|\\/tag\\/|\\/category\\/|\\/topics?\\/|\\/news\\/?$|\\/blog\\/?$|\\/search/i.test(path)) return false;\n  \n  // Check if any topic keyword appears in the URL\n  const matchCount = topicWords.filter(w => lower.includes(w)).length;\n  return matchCount >= 1;\n}\n\n// Perplexity citations + research JSON sources\nconst citations = (input.citations || []).filter(u => u && u.startsWith('http'));\nconst researchSources = (research.sources || []).filter(u => u && u.startsWith('http'));\nconst allUrls = [...citations, ...researchSources].filter((v, i, a) => a.indexOf(v) === i);\n\n// Filter for relevant sources\nlet relevantSources = allUrls.filter(isRelevantUrl).slice(0, 3);\n\n// Fallback: if no keyword-matched sources, take citations with real article paths\nif (relevantSources.length === 0 && citations.length > 0) {\n  relevantSources = citations.filter(u => {\n    const path = u.toLowerCase().replace(/^https?:\\/\\/[^/]+/, '');\n    return path.length > 20 && !BAD_DOMAINS.some(d => u.toLowerCase().includes(d));\n  }).slice(0, 3);\n}\n\nreturn [{\n  json: {\n    topic: research.topic || '',\n    headline: research.headline || '',\n    summary: research.summary || '',\n    key_quotes: (research.key_quotes || []).filter(q => q && q.text && q.author),\n    topicCategory: research.topic_category || '',\n    sources: relevantSources,\n    sourceLinks: relevantSources,\n    templateType: prevData.templateType,\n    sourcesStr: prevData.sourcesStr,\n    timeSlot: prevData.timeSlot,\n    date: new Date().toISOString().split('T')[0],\n  }\n}];"
                },
                "id": "parse-research",
                "name": "Parse Research",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    750,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const https = require('https');\nconst supabaseUrl = $env.SUPABASE_URL;\nconst supabaseKey = $env.SUPABASE_SERVICE_KEY;\n\nconst hostname = supabaseUrl.replace('https://', '');\nconst options = {\n  hostname,\n  path: '/rest/v1/blog_post_translations?locale=eq.en&select=title&order=created_at.desc&limit=10',\n  headers: {\n    'apikey': supabaseKey,\n    'Authorization': 'Bearer ' + supabaseKey,\n  }\n};\n\nconst data = await new Promise((resolve, reject) => {\n  const req = https.get(options, (res) => {\n    let body = '';\n    res.on('data', chunk => body += chunk);\n    res.on('end', () => resolve(JSON.parse(body)));\n  });\n  req.on('error', reject);\n});\n\nconst existingTitles = data.map(r => r.title.toLowerCase());\nconst proposedTopic = ($input.first().json.topic || '').toLowerCase();\n\nconst isDuplicate = existingTitles.some(t => {\n  const words = proposedTopic.split(' ').filter(w => w.length > 4);\n  if (words.length === 0) return false;\n  const matches = words.filter(w => t.includes(w));\n  return matches.length >= 3;\n});\n\nreturn [{\n  json: {\n    ...$input.first().json,\n    isDuplicate,\n    existingTitles,\n  }\n}];"
                },
                "id": "dedup-check",
                "name": "Dedup Check",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1000,
                    0
                ]
            },
            {
                "parameters": {
                    "conditions": {
                        "options": {
                            "caseSensitive": true,
                            "leftValue": "",
                            "typeValidation": "strict"
                        },
                        "conditions": [
                            {
                                "id": "dedup-condition",
                                "leftValue": "={{ $json.isDuplicate }}",
                                "rightValue": false,
                                "operator": {
                                    "type": "boolean",
                                    "operation": "equals",
                                    "singleValue": true
                                }
                            }
                        ],
                        "combinator": "and"
                    }
                },
                "id": "if-not-duplicate",
                "name": "Not Duplicate?",
                "type": "n8n-nodes-base.if",
                "typeVersion": 2,
                "position": [
                    1250,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const input = $input.first().json;\nconst { existingTitles, isDuplicate, ...topicData } = input;\n\nreturn [{\n  json: {\n    ...topicData,\n    status: 'ready_for_generation',\n    discoveredAt: new Date().toISOString(),\n  }\n}];"
                },
                "id": "format-output",
                "name": "Format Output",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1500,
                    0
                ]
            },
            {
                "parameters": {
                    "jsCode": "const input = $input.first().json;\nreturn [{\n  json: {\n    status: 'skipped_duplicate',\n    topic: input.topic,\n    message: 'Topic was too similar to recent posts. Will try again next slot.',\n  }\n}];"
                },
                "id": "skip-duplicate",
                "name": "Skip (Duplicate)",
                "type": "n8n-nodes-base.code",
                "typeVersion": 2,
                "position": [
                    1500,
                    300
                ]
            },
            {
                "id": "call-content-gen",
                "name": "Call Content Generation",
                "type": "n8n-nodes-base.httpRequest",
                "typeVersion": 4.2,
                "position": [
                    1740,
                    0
                ],
                "parameters": {
                    "method": "POST",
                    "url": "http://localhost:5678/webhook/doppler-content-gen",
                    "sendBody": true,
                    "specifyBody": "json",
                    "jsonBody": "={{ JSON.stringify($json) }}",
                    "options": {
                        "timeout": 300000
                    }
                }
            },
            {
                "id": "call-image-pipeline",
                "name": "Call Image Pipeline",
                "type": "n8n-nodes-base.httpRequest",
                "typeVersion": 4.2,
                "position": [
                    1980,
                    0
                ],
                "parameters": {
                    "method": "POST",
                    "url": "http://localhost:5678/webhook/doppler-image-gen",
                    "sendBody": true,
                    "specifyBody": "json",
                    "jsonBody": "={{ JSON.stringify($json) }}",
                    "options": {
                        "timeout": 120000
                    }
                }
            },
            {
                "id": "call-publish",
                "name": "Call Publish",
                "type": "n8n-nodes-base.httpRequest",
                "typeVersion": 4.2,
                "position": [
                    2220,
                    0
                ],
                "parameters": {
                    "method": "POST",
                    "url": "http://localhost:5678/webhook/doppler-publish",
                    "sendBody": true,
                    "specifyBody": "json",
                    "jsonBody": "={{ JSON.stringify($json) }}",
                    "options": {
                        "timeout": 360000
                    }
                }
            }
        ],
        "connections": {
            "Schedule": {
                "main": [
                    [
                        {
                            "node": "Source Rotation",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Source Rotation": {
                "main": [
                    [
                        {
                            "node": "Perplexity Research",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Perplexity Research": {
                "main": [
                    [
                        {
                            "node": "Parse Research",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Parse Research": {
                "main": [
                    [
                        {
                            "node": "Dedup Check",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Dedup Check": {
                "main": [
                    [
                        {
                            "node": "Not Duplicate?",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Not Duplicate?": {
                "main": [
                    [
                        {
                            "node": "Format Output",
                            "type": "main",
                            "index": 0
                        }
                    ],
                    [
                        {
                            "node": "Skip (Duplicate)",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Format Output": {
                "main": [
                    [
                        {
                            "node": "Call Content Generation",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Call Content Generation": {
                "main": [
                    [
                        {
                            "node": "Call Image Pipeline",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            },
            "Call Image Pipeline": {
                "main": [
                    [
                        {
                            "node": "Call Publish",
                            "type": "main",
                            "index": 0
                        }
                    ]
                ]
            }
        },
        "authors": "Roman Pochtman",
        "name": null,
        "description": null,
        "autosaved": false,
        "workflowPublishHistory": [
            {
                "createdAt": "2026-02-26T02:18:04.490Z",
                "id": 165,
                "workflowId": "M6Gm4TKM6YwGzygG",
                "versionId": "f2f6673a-8729-4982-861a-0cf88d797ebe",
                "event": "activated",
                "userId": "00f12e0f-5634-430b-ab08-fd0aefa1a039"
            }
        ]
    }
}
